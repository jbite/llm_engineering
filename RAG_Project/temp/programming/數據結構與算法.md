# 數據結構與算法

### 物理結構分類

邏輯結構表示 稱為物理結構 常見的物理結構有順序存儲結構

順序存儲結構有一定的弊端 插入跟移除的效率不佳

可以用鏈式存儲結構來取代 一般查找效率不高 但插入跟移除元素的效率好

#### 什麼是算法

解決方法的策略機制 並且要在有限時間內獲得所要求的輸出

一個好的算法:

* 花最少的時間完成
* 占用最少的記憶體

### 演算法分析

#### 演算法的時間複雜度分析

#### 演算法的空間複雜度分析



## 順序表插入

又稱數組 在內存中都排在一起

隊列-FIFO

FILO



數列的實作

```go 
package ArrayList

import (
	"errors"
	"fmt"
)

type List interface {
	Size() int
	Get(index int) (interface{}, error)         //抓取第幾個元素
	Set(index int, newval interface{}) error    //修改數據
	Insert(index int, newval interface{}) error //插入數據
	Append(newval interface{})                  //追加數據
	Clear()                                     //清空
	Delete(index int) error                     //刪除數據
	String() string                             //返回字符串
}

type ArrayList struct {
	dataStore []interface{} //數據存儲
	TheSize   int           //數組的大小
}

func NewArrayList() *ArrayList {
	list := new(ArrayList)                      //初始化結構體
	list.dataStore = make([]interface{}, 0, 10) //開闢空間10個
	list.TheSize = 0
	return list
}

func (list *ArrayList) Size() int {
	return list.TheSize
}

//抓取數據
func (list *ArrayList) Get(index int) (interface{}, error) {
	if index < 0 || index >= list.TheSize {
		return nil, errors.New("index out of size")
	}
	return list.dataStore[index], nil
}

func (list *ArrayList) Append(newval interface{}) {

	list.dataStore = append(list.dataStore, newval)
	list.TheSize++

}

func (list *ArrayList) String() string {
	return fmt.Sprint(list.dataStore)
}

func (list *ArrayList) Clear() {
	list.dataStore = make([]interface{}, 0, 10)
	list.TheSize = 0
}

func (list *ArrayList) Set(index int, newval interface{}) error {
	if index < 0 || index >= list.TheSize {
		return errors.New("index out of size")
	}
	list.dataStore[index] = newval //設置
	return nil
}

func (list *ArrayList) Insert(index int, newval interface{}) error {
	if index < 0 || index >= list.TheSize {
		return errors.New("index out of size")
	}
	list.checkisFull()

	list.dataStore = list.dataStore[:list.TheSize+1]
	// fmt.Printf("%v,%v\n", list.TheSize, len(list.dataStore))
	for i := list.TheSize; i > index; i-- {
		// fmt.Println(i)
		list.dataStore[i] = list.dataStore[i-1]
	}
	list.dataStore[index] = newval
	list.TheSize++
	return nil
}

func (list *ArrayList) checkisFull() {
	if list.TheSize == cap(list.dataStore) { //判斷內存使用
		newdataStore := make([]interface{}, 0, 2*list.TheSize)
		// copy(newdataStore, list.dataStore)
		newdataStore = append(newdataStore, list.dataStore...) //滿了就拷貝
		list.dataStore = newdataStore
	}
}
func (list *ArrayList) Delete(index int) error { //刪除
	if index < 0 || index >= list.TheSize {
		return errors.New("index out of size")
	}
	list.dataStore = append(list.dataStore[:index], list.dataStore[index+1:]...)
	list.TheSize--

	return nil
}

```

### Iterator模式的數列實現

```go
package ArrayList

import (
	"errors"
	"fmt"
)

type Iterator interface {
	HasNext() bool
	Next() (interface{}, error)
	Remove()
	GetIndex() int
}

type Iterable interface {
	Iterator() Iterator
}

type ArrayListIterator struct {
	list     *ArrayList
	CurIndex int
}

func (l *ArrayList) Iterator() Iterator {
	iterator := &ArrayListIterator{list: l, CurIndex: 0}
	return iterator
}

func (a *ArrayListIterator) HasNext() bool {
	return a.CurIndex < a.list.TheSize
}

func (a *ArrayListIterator) Next() (interface{}, error) {
	if !a.HasNext() {
		return nil, errors.New("沒有下一個")
	}
	value, err := a.list.Get(a.CurIndex)
	a.CurIndex++
	return value, err
}

func (a *ArrayListIterator) Remove() {
	if len(a.list.dataStore) <= 0 {
		fmt.Println("沒有元素可以被移除")
	}
	a.CurIndex--
	a.list.Delete(a.CurIndex)

}

func (a *ArrayListIterator) GetIndex() int {
	return a.CurIndex
}

```

### Stack用數列實現

```go
package ArrayList

type StackArray interface {
	Clear()           //清空
	Size() int        //大小
	Pop() interface{} //彈出
	Push(interface{}) //押入
	IsFull() bool
	IsEmpty() bool
}

type Stack struct {
	StackList *ArrayList
	capSize   int
}

func NewArrayListStack(n int) *Stack {
	s := &Stack{capSize: n}
	s.StackList = NewArrayList()
	s.StackList.TheSize = 0
	return s
}

func (s *Stack) Clear() {
	s.StackList.TheSize = 0
	s.StackList.Clear()
}
func (s *Stack) Size() int {
	return s.StackList.TheSize
}
func (s *Stack) Pop() interface{} {
	if s.IsEmpty() {
		return nil
	}
	val, _ := s.StackList.Get(s.StackList.TheSize - 1)
	s.StackList.Delete(s.StackList.TheSize - 1)
	return val
}
func (s *Stack) Push(data interface{}) {
	if !s.IsFull() {
		s.StackList.Append(data)

	}
}
func (s *Stack) IsFull() bool {
	if s.StackList.TheSize == s.capSize {
		return true
	}
	return false
}
func (s *Stack) IsEmpty() bool {
	if s.StackList.TheSize == 0 {
		return true
	}
	return false
}

```

### Stack用Iterator實現

```go
type StackX struct {
	StackList *ArrayList
	capSize   int
	Myit      Iterator //加入一個迭代器
}
//更改工廠方法，讓迭代器初始化
func NewArrayListStackX(n int) *StackX {
	s := &StackX{capSize: n}
	s.StackList = NewArrayList()
	s.Myit = s.StackList.Iterator()
	return s
}


```

運行

```go
func main2() {
	stack := ArrayList.NewArrayListStackX(10)
	stack.Push("ha")
	stack.Push(123)
	stack.Push("A")
	stack.Push("B")
	stack.Push("C")
	stack.Push("D")
	
	for it := stack.Myit; it.HasNext(); {
		item, _ := it.Next()
		fmt.Println(item)
	}
}
```

### Stack實現遞歸

```go
func main() {
	mystack := ArrayList.NewArrayListStack(10)
	num := 1000000
	mystack.Push(num)
	last := 0 //結果
	for !mystack.IsEmpty() {
		if num == 0 {
			break
		}
		data := mystack.Pop()
		last += data.(int)
		num--
		mystack.Push(num)
	}
	fmt.Println(last)
}
```

#### 菲波納契數列

1  1 2 3 5 8 13 21 34 55

```go
func main() {
	feibo := ArrayList.NewArrayListStack(10)
	result := 1
	times := 100
	index := 1
	for index <= times {
		if index == 1 || index == 2 {
			feibo.Push(1)
			index++
			fmt.Println(result)
			continue
		}

		temp1 := feibo.Pop()
		temp2 := feibo.Pop()
		result = temp1.(int) + temp2.(int)
		feibo.Push(temp1)
		feibo.Push(result)
		index++
		fmt.Println(result)
	}
}
```

### 使用遞歸實現遍歷文件夾

```go
package main

import (
	"errors"
	"fmt"
	"io/ioutil"
)

func GetAll(path string, files []string) ([]string, error) {
	read, err := ioutil.ReadDir(path) //讀取文件夾
	if err != nil {
		return files, errors.New("文件夾不可讀取")
	}
	for _, fi := range read { //循環每個文件夾或者文件
		if fi.IsDir() { //判斷是否是文件夾
			fulldir := path + "\\" + fi.Name()
			files = append(files, fulldir) //追加路徑
			files, _ = GetAll(fulldir, files)
		} else {
			fulldir := path + "\\" + fi.Name()
			files = append(files, fulldir)
		}
	}
	return files, nil
}

func main() {
	path := "D:\\AutoMaintainPython\\bootstrap-3.3.7\\bootstrap-3.3.7"
	files := []string{}
	files, _ = GetAll(path, files)    //抓取所有文件
	for i := 0; i < len(files); i++ { //打印路徑
		fmt.Println(files[i])
	}
}

```

### Stack實現文件深度優先遍歷

```go
func main() {
	stack := StackArray.NewStack(100)
	path := "D:\\AutoMaintainPython\\bootstrap-3.3.7\\bootstrap-3.3.7"
	files := []string{}
	stack.Push(path)
	for !stack.IsEmpty() {
		getpath := stack.Pop().(string)
		read, _ := ioutil.ReadDir(getpath)

		for _, fi := range read {
			if fi.IsDir() {
				fullpath := getpath + "\\" + fi.Name()
				files = append(files, fullpath)
				stack.Push(fullpath)

			} else {
				fullpath := getpath + "\\" + fi.Name()
				files = append(files, fullpath)
			}
		}
	}

	for i := 0; i < len(files); i++ {
		fmt.Println(files[i])
	}
}
```



### sparsearray 稀疏數組

功能:

* 存盤退出
* 續上盤

問題:會記錄很多無意義的數據

紀錄數組共有幾行幾列 有多少個不同的值

把具有不同值的元素的行列及值紀錄在一個小規模的數組中，從而縮小數據的規模

![image-20200523140351607](C:\Users\bited\AppData\Roaming\Typora\typora-user-images\image-20200523140351607.png)

* 紀錄數組有幾行幾列 有多少非零值
* 把非零值的元素及行列紀錄在一個小規模的數組中 縮小數據的佔用空間

```go
var (
	chessMap [11][11]int
)

type SparseNode struct {
	Row    int
	Column int
	Data   interface{}
}

func NewSparseNode(r, c int, d interface{}) *SparseNode {
	n := new(SparseNode)
	n.Row = r
	n.Column = c
	n.Data = d
	return n
}

type SparseArray struct {
	RowSize int
	ColSize int
	Default int
	Array   []*SparseNode
}

func (s *SparseArray) Save() {
	//(1)遍歷chessMap 如果我們發現有一個元素的值不為0,就創建一個node結構體
	//(2)將其放入到對應的切片中
	//標準的稀疏數組應該還有表示原始二維數組的規模(行和列,默認值)
	for i, v := range chessMap {
		s.RowSize++
		s.ColSize = len(v)
		for j, w := range v {
			if w != 0 {
				cn := NewSparseNode(i, j, w)
				s.Array = append(s.Array, cn)
			}
		}
	}
	//將讀出的結果寫入文件
	var str string
	str = fmt.Sprintf("%d %d %d\n", s.RowSize, s.ColSize, s.Default)
	for _, v := range s.Array {
		s := fmt.Sprintf("%d %d %d\n", v.Row, v.Column, v.Data)
    //組合字串
		str += s
	}
  //將產生的壓縮字串存到文件中
	filepath := "sparsedata"
	ioutil.WriteFile(filepath, []byte(str), 0644)
}

func main() {
	//先創建一個原始數組
	// var chessMap [11][11]int
	var sparseArr SparseArray

	chessMap[1][2] = 1 //黑子
	chessMap[2][3] = 2 //藍子

	//輸出原始的數組
	for _, v := range chessMap {
		for _, w := range v {
			fmt.Printf("%d\t", w)
		}
		fmt.Println("")
	}
	//將稀疏數組 儲存
	sparseArr.Save()
//恢復原始的數組
var chessMap2 [11][11]int
//打開這個文件
	filepath := "sparsedata"
	file, _ := os.OpenFile(filepath, os.O_RDONLY, 0644)
	defer file.Close()

	reader := bufio.NewReader(file)
  //遍歷文件的每一行
	for true {
		str, err := reader.ReadString('\n')
		if err == nil {
      //轉換字串為整數
			ns := strings.Fields(str)
			v1, _ := strconv.Atoi(ns[0])
			v2, _ := strconv.Atoi(ns[1])
			v3, _ := strconv.Atoi(ns[2])
			if v1 >= len(chessMap2) {
				continue
			} else {
				chessMap2[v1][v2] = v3
			}
		} else if err == io.EOF {
			break
		}
	}
	//輸出chessMap2的數組
	fmt.Println("chessMap2:")
	for _, v := range chessMap2 {
		for _, w := range v {
			fmt.Printf("%d\t", w)
		}
		fmt.Println("")
	}
	fmt.Println()
}

```

### 隊列(queue)

銀行排隊

可以用數組或是鏈表實作

遵循先入先出的原則 先存入的隊列的數據 要先取出 後存入的後取出

![image-20200523172744485](C:\Users\bited\AppData\Roaming\Typora\typora-user-images\image-20200523172744485.png)

隊列本身是有序列表 若使用數組的結構來存儲隊列的數據 必需要聲明maxSize



因為隊列的輸出輸入是分別從前後端來處理 因此需要變量front及rear分別記錄隊列前後端的下標 front會隨著數據輸出而改變 而rear會隨著數據輸入而改變

![image-20200523173249609](C:\Users\bited\AppData\Roaming\Typora\typora-user-images\image-20200523173249609.png)

當我們將數據存入隊列時稱為addqueue 

當數據存入隊列時，將尾指針往後移

當rear==maxSize時，隊列滿



#### 非環形的隊列

代碼實現:

1. 創建一個數組array 放在
2. 起始時 front索引指向-1
3. rear索引指向-1
4. AddQueue //加入數據到隊列
5. GetQeuee//從隊列取出數據
6. ShowQueue顯示隊列中的元素

```go
//建立一個隊列結構體
type SingleQueue struct {
	MaxSize int
	Front   int
	Rear    int
	Array   []interface{}
}

func NewQueue(l int) *SingleQueue {
	q := new(SingleQueue)
	q.MaxSize = l
	q.Rear = -1
	q.Front = -1
	q.Array = make([]interface{}, l)
	return q
}

//添加數據到隊列
func (q *SingleQueue) AddQueue(d interface{}) (err error) {
	//先判斷隊列是否已滿
	if q.Rear == q.MaxSize-1 { //rear是隊列尾部 (含最後的元素))
		return errors.New("Queue is full.")
	}

	q.Rear++ //rear 往後移
	q.Array[q.Rear] = d
	return nil
}

//顯示隊列 找到隊首 遍歷到隊尾
func (q *SingleQueue) ShowQueue() {
	fmt.Println("隊列當前的情況是:")
	//front不包含隊首的元素
	for i := q.Front + 1; i <= q.Rear; i++ {
		fmt.Printf("array[%d]=%v\n", i, q.Array[i])
	}
}
func (q *SingleQueue) GetQueue() (val interface{}, err error) {
	//先判斷隊列是否為空
	if q.Rear == q.Front {
		return nil, errors.New("Queue Empty")
	}
	q.Front++
	val = q.Array[q.Front]
	return
}
```



```go
package Queue

type Queue interface {
	Size() int
	Push(data interface{})
	Pop() interface{}
	Front() interface{}
	End() interface{}
	IsEmpty() bool
	Clear()
}

type SinQueue struct {
	DataStore []interface{} //隊列的數據存儲
	TheSize   int           //隊列的大小
	Head      int           //頭部index
	Tail      int           //尾部index
}

func NewQueue() *SinQueue {
	q := &SinQueue{}
	q.DataStore = make([]interface{}, 0)
	q.TheSize = 0
	return q
}

func (q *SinQueue) Size() int {
	return q.TheSize
}
func (q *SinQueue) Push(data interface{}) {
	q.DataStore = append(q.DataStore, data)
	q.TheSize++
}
func (q *SinQueue) Pop() interface{} {
	if !q.IsEmpty() {
		if q.TheSize > 1 {
			data := q.Front()
			q.DataStore = q.DataStore[1:]
			q.TheSize--
			return data
		}
		data := q.Front()
		q.Clear()
		return data
	}
	return nil
}

func (q *SinQueue) Front() interface{} {
	return q.DataStore[0]
}
func (q *SinQueue) End() interface{} {
	return q.DataStore[q.TheSize-1]
}

func (q *SinQueue) IsEmpty() bool {
	if q.TheSize == 0 {
		return true
	}
	return false
}
func (q *SinQueue) Clear() {
	q.DataStore = make([]interface{}, 0)
	q.TheSize = 0
}

```





#### 環形隊列

使用取模來返回數列頭部

尾索引的下一個為頭索引時表示隊列滿

將隊列容量空出一個做為約定 讓隊列滿時可以不會因為index溢出而加入失敗

```go
//思路
//隊列MaxSize-1==可存放資料的空間
//隊列滿的時候 就是(tail +1)%maxSize == head
//tail == head 時，隊列為空
//隊列現有元素個數==(tail+maxSize)-head
//初始時 tail == head == 0
//如何統計 (tail+maxSize-head)%maxSize

type CircleQueue struct {
	MaxSize int
	Head    int
	Tail    int
	Array   []interface{}
}

//NewCircleQueue (l int) *CircleQueue CircleQueue的工廠函數
func NewCircleQueue(l int) *CircleQueue {
	c := new(CircleQueue)
	c.MaxSize = l
	c.Head = 0
	c.Tail = 0
	c.Array = make([]interface{}, l)
	return c
}

//Push 推值入隊列
func (c *CircleQueue) Push(d interface{}) (err error) {
	//判斷隊列是否已滿
	if c.IsFull() {
		err = errors.New("隊列已滿")
		return
	}
	c.Array[c.Tail] = d
	c.Tail++
	if c.Tail == c.MaxSize {
		c.Tail = 0
	}
	return
}

//彈值出隊列
func (c *CircleQueue) Pop() (d interface{}, err error) {
	//判斷隊列是否為空
	if c.IsEmpty() {
		err = errors.New("隊列為空")
		return d, err
	}

	//把值取出隊列
	d = c.Array[c.Head]
	c.Head++
	if c.Head == c.MaxSize {
		c.Head = 0
	}

	return
}

//判斷隊列是否已滿
func (c *CircleQueue) IsFull() bool {
	return (c.Tail+1)%c.MaxSize == c.Head
}

//判斷隊列是否空
func (c *CircleQueue) IsEmpty() bool {
	return c.Tail == c.Head
}

//取出環形隊列元素個數
func (c *CircleQueue) Size() int {
	return (c.Tail + c.MaxSize - c.Head) % c.MaxSize
}

func (c *CircleQueue) ShowCircleQueue() {
	//判斷隊列是否為空
	if c.IsEmpty() {
		fmt.Println("Array is empty")
		return
	}
	for i := c.Head; i < c.Head+c.Size(); i++ {
		//新增一個輔助變數
		a := i % c.MaxSize
		fmt.Printf("Array[%d]: %v\n", i-c.Head+1, c.Array[a])
	}
}
```

### Queue實現文件夾廣度優先遍歷

```go
package main

import (
	"fmt"
	"io/ioutil"

	"./Queue"
)

func main() {
	q := Queue.NewRingQueue(100)
	path := "D:\\oldboy"
	files := []string{}
	files = append(files, path)
	q.Push(path)

	for {
		getpath := q.Pop()
		if getpath == nil {
			break
		}
		path := getpath.(string)
		files = append(files, path)
		read, _ := ioutil.ReadDir(path)
		for _, fi := range read {
			if fi.IsDir() {
				fullpath := path + "\\" + fi.Name()
				files = append(files, fullpath)
				q.Push(fullpath)
			} else {
				fullpath := path + "\\" + fi.Name()
				files = append(files, fullpath)
			}
		}
	}
	for _, file := range files {
		fmt.Println(file)
	}
}

```



### 單鏈表(linked list)

![image-20200524085050373](C:\Users\bited\AppData\Roaming\Typora\typora-user-images\image-20200524085050373.png)

單鏈表是一個有序的列表 透過struct的next指出下一個結構體的位置

![image-20200524085635567](C:\Users\bited\AppData\Roaming\Typora\typora-user-images\image-20200524085635567.png)

真實的GO存放數據的樣子 所以Next是存放結構體的變數的指針 再透過指針指到值

![image-20200524090432649](C:\Users\bited\AppData\Roaming\Typora\typora-user-images\image-20200524090432649.png)

一般來說 為了比較好的單鏈表進行增刪改查的操作 都會給link list 設置一個頭節點

頭節點的作用指用來標示頭部

單鏈表程式碼

```go
package main

import (
	"errors"
	"fmt"
)

//使用帶head頭的單向鏈表實現水滸英雄排行榜管理

type LinkList struct {
	Index    int
	Name     string
	NickName string
	Next     *LinkList
}

func HeadLinkList() *LinkList {
	list := new(LinkList)
	return list
}
func NewLinkList(index int, name string, nickname string) *LinkList {
	list := new(LinkList)
	list.Index = index
	list.Name = name
	list.NickName = nickname
	return list
}

//Push 給鏈表插入一個結點
//編寫第一種插入方法 在單鏈表的最後加入
//1. 先找到該鏈表的最後這個結點
//2. 創建輔助結點[跑腿的]
//3.如果Next為空 就將新結點加入
func (h *LinkList) Push(newnode *LinkList) {
	temp := h
	for {
		if temp.Next == nil {
			break
		}
		temp = temp.Next //讓temp不斷的指向下一個節點
	}
	temp.Next = newnode //將結點指向新結點
}

//SortPush 編寫第2種插入方法 根據no的編號從小到大插入
//讓temp在適當的位置先插入結點，因為跳過後 temp無法再回頭
func (h *LinkList) SortPush(newnode *LinkList) (err error) {
	temp := h
	if temp.Next == nil { //已經到鏈表的最後了
		temp.Next = newnode
		return
	} else if temp.Next.Index == newnode.Index {
		err = errors.New("Index ruplicate")
		fmt.Println(newnode.Name, err)
		return
	} else if newnode.Index < temp.Next.Index {
		//就應該插入下一跳的前面
		newnode.Next = temp.Next
		temp.Next = newnode
	} else if newnode.Index > temp.Next.Index {
		//當newnode index比現在結點的indez大就遞歸
		err = temp.Next.SortPush(newnode)
		return
	}
	return
}

//DeleteNode 刪除結點
func (h *LinkList) DeleteNode(index int) (err error) {
	temp := h
	for {
		if temp.Next == nil {
			err = errors.New("結點不存在")
			fmt.Println(index, err)
			return
		} else if temp.Next.Index != index {
			temp = temp.Next
		} else if temp.Next.Index == index {
			temp.Next = temp.Next.Next
			fmt.Println(temp.Next.Name, "已經刪除")
			return
		}
	}
}

func (head *LinkList) ShowLinkList() {
	temp := head
	for {
		if temp.Next != nil {
			fmt.Printf("Index:%3v\t, Name:%-5s\t, Nickname: %-5s\n",
				temp.Next.Index,
				temp.Next.Name,
				temp.Next.NickName)
			temp = temp.Next //將結點指向下一個節點
		} else {
			break
		}
	}
	return
}
func main() {
	head := HeadLinkList()
	hero1 := NewLinkList(6, "宋江", "及時雨")
	hero2 := NewLinkList(3, "武松", "行者")
	hero3 := NewLinkList(5, "盧俊義", "玉麒麟")
	hero4 := NewLinkList(7, "林沖", "豹子頭")
	hero5 := NewLinkList(101, "吳用", "智多星")
	hero6 := NewLinkList(1, "公孫勝", "入雲龍")
	head.SortPush(hero1)
	head.SortPush(hero2)
	head.SortPush(hero3)
	head.SortPush(hero4)
	head.SortPush(hero5)
	head.SortPush(hero6)
	head.ShowLinkList()
	head.DeleteNode(5)
	head.DeleteNode(5)
	// fmt.Printf("%#v\n", head)
	head.ShowLinkList()
}

```

#### 單鏈表實現Stack

```go
package Link

import "fmt"

type LinkStack interface {
	IsEmpty() bool
	Push(data interface{})
	Pop() (data interface{})
	Length() int
}

func NewLinkStack() *Node {
	l := new(Node)
	return l
}

func (l *Node) IsEmpty() bool {
	if l.Next == nil {
		return true
	}
	return false
}
func (l *Node) Push(data interface{}) {
	newnode := &Node{data: data}
	newnode.Next = l.Next
	l.Next = newnode
}
func (l *Node) Pop() (data interface{}) {
	if l.IsEmpty() {
		fmt.Println("Stack is Empty")
		return
	}
	data = l.Next.data
	l.Next = l.Next.Next
	return data
}

func (l *Node) Length() int {
	temp := l.Next
	len := 0
	for temp.Next != nil {
		len++
		temp = temp.Next
	}
	len++
	return len
}

func (l *Node) ShowStack() {
	temp := l.Next
	for temp.Next != nil {
		fmt.Println(temp.data)
		temp = temp.Next
	}
	fmt.Println(temp.data)

}

```

#### 單鏈表實現Queue

```go
package Link

import "fmt"

type LinkQueue interface {
	Length() int
	Push(data interface{})
	Pop() (data interface{})
}

type QueueNode struct {
	Head *Node
	Tail *Node
}

func NewQueueNode() *QueueNode {
	q := &QueueNode{}
	return q
}

func (qlk *QueueNode) Length() int {
	var temp *Node
	temp = qlk.Head
	len := 0
	if temp != nil {
		len++
		for temp.Next != nil {
			len++
			temp = temp.Next
		}
	}
	return len
}
func (qlk *QueueNode) Push(data interface{}) {
	temp := qlk.Head
	newnode := &Node{data: data}
	if temp == nil {
		qlk.Head = newnode
		qlk.Tail = newnode
	} else {
		qlk.Head = newnode
		newnode.Next = temp
	}
}
func (qlk *QueueNode) Pop() (data interface{}) {
	if qlk.Head == nil {
		fmt.Println("Queue is empty")
		return
	}
	temp := qlk.Head
	data = qlk.Tail.data
	if qlk.Head == qlk.Tail {
		qlk.Head = nil
		qlk.Tail = nil

	} else {
		for temp.Next != qlk.Tail {
			temp = temp.Next
		}
		qlk.Tail = temp
		temp.Next = nil
	}
	return data
}
```



### 雙向鏈表(DuLinkList )

```go
package main

import (
	"errors"
	"fmt"
)

//使用帶head頭的單向鏈表實現水滸英雄排行榜管理
//聲明雙向列表結構
type DuLinkList struct {
	Index    int
	Name     string
	NickName string
	Prev     *DuLinkList //指向前一個節點
	Next     *DuLinkList //指向下一個節點
}

func HeadDuLinkList() *DuLinkList {
	list := new(DuLinkList)
	return list
}
func NewDuLinkList(index int, name string, nickname string) *DuLinkList {
	list := new(DuLinkList)
	list.Index = index
	list.Name = name
	list.NickName = nickname
	return list
}

func (h *DuLinkList) Push(newnode *DuLinkList) {
	temp := h
	for {
		if temp.Next == nil {
			break
		}
		temp = temp.Next //讓temp不斷的指向下一個節點
	}
	newnode.Prev = temp
	temp.Next = newnode //將結點指向新結點
}

func (h *DuLinkList) DuSortPush(newnode *DuLinkList) (err error) {
	temp := h
	if temp.Next == nil { //已經到鏈表的最後了
		newnode.Prev = temp
		temp.Next = newnode
		return
	} else if temp.Next.Index == newnode.Index {
		err = errors.New("Index ruplicate")
		fmt.Println(newnode.Name, err)
		return
	} else if newnode.Index < temp.Next.Index {
		//就應該插入下一跳的前面
		newnode.Next = temp.Next
		newnode.Prev = temp
		temp.Next.Prev = newnode
		temp.Next = newnode
	} else if newnode.Index > temp.Next.Index {
		//當newnode index比現在結點的indez大就遞歸
		err = temp.Next.DuSortPush(newnode)
		return
	}
	return
}

//DeleteNode 刪除結點
func (h *DuLinkList) DuDeleteNode(index int) (err error) {
	temp := h
	for {
		if temp.Next == nil && temp.Index != index {
			err = errors.New("結點不存在")
			fmt.Println(index, err)
			return
		} else if temp.Index != index {
			temp = temp.Next
		} else if temp.Index == index {

			if temp.Next != nil {
				temp.Next.Prev = temp.Prev
				temp.Prev.Next = temp.Next
			} else {
				fmt.Println(temp.Prev)
				temp.Prev.Next = HeadDuLinkList().Next
			}

			fmt.Println(temp.Name, "已經刪除")
			return
		}
	}
}

func (head *DuLinkList) ShowDuLinkList() {
	temp := head
	for {
		if temp.Next != nil {
			fmt.Printf("Index:%3v\t, Name:%-5s\t, Nickname: %-5s\n",
				temp.Next.Index,
				temp.Next.Name,
				temp.Next.NickName,
			)
			temp = temp.Next //將結點指向下一個節點
		} else {
			break
		}
	}
	return
}

func (head *DuLinkList) ReverseShowDuLinkList() {
	temp := head
	for {
		if temp.Next == nil {
			break
		}
		temp = temp.Next
	}
	for {
		if temp != head {
			fmt.Printf("Index:%3v\t, Name:%-5s\t, Nickname: %-5s\n",
				temp.Index,
				temp.Name,
				temp.NickName,
			)
			temp = temp.Prev //將結點指向上一個節點
		} else {
			return
		}
	}
}
func main() {
	head := HeadDuLinkList()
	hero1 := NewDuLinkList(6, "宋江", "及時雨")
	hero2 := NewDuLinkList(103, "武松", "行者")
	hero3 := NewDuLinkList(5, "盧俊義", "玉麒麟")
	hero4 := NewDuLinkList(7, "林沖", "豹子頭")
	hero5 := NewDuLinkList(1, "吳用", "智多星")
	hero6 := NewDuLinkList(2, "公孫勝", "入雲龍")
	head.DuSortPush(hero1)
	head.DuSortPush(hero2)
	head.DuSortPush(hero3)
	head.DuSortPush(hero4)
	head.DuSortPush(hero5)
	head.DuSortPush(hero6)
	head.ShowDuLinkList()
	head.DuDeleteNode(103)
	head.ShowDuLinkList()

}

```

### 單向環形列表

在刪除時，需要一個helper，這個helper指向末尾的結點，在temp前進時，helper也需要跟著前進

```go
package main

import (
	"errors"
	"fmt"
)

//定義一個環形鏈表
type CirLnLs struct {
	Index int
	Name  string
	Next  *CirLnLs
}

//工廠函數
func NewCirLnLs(index int, name string) *CirLnLs {
	c := new(CirLnLs)
	c.Index = index
	c.Name = name
	c.Next = c
	return c
}

func (c *CirLnLs) InsertNode(d *CirLnLs) {
	temp := c
	for {
		if temp.Next == c { //temp就是尾巴了
			temp.Next = d
			d.Next = c
			return
		}
		temp = temp.Next
	}
}
//刪除節點，並且返回現在的頭部指針
func (c *CirLnLs) DeleteNode(index int) (temp *CirLnLs, err error) {
	temp = c
	helper := c.NewHelper()
	//如果只有一個節點 且節點Index是要刪除的值
	if temp.Next == c && temp.Index == index {
		temp.Next = nil//將Next設為nil，表示環形鏈表為空
		return c, nil
	}

	for {
		//找到最後 而且沒有正確的index
		if temp.Next == c && temp.Index != index {
			err = errors.New("Index not found")
			return
		}
		if c.Index == index {
			c = c.Next
			helper.Next = c
			return c, nil
		}
		if temp.Index == index {
			fmt.Println("找到", index)
			helper.Next = temp.Next
			return c, nil
		}

		temp = temp.Next
		helper = helper.Next
	}
}
//產生helper指針
func (c *CirLnLs) NewHelper() (helper *CirLnLs) {
	helper = c
	for {
		if helper.Next == c {
			return
		} else {
			helper = helper.Next
		}
	}
}
//顯示鏈表
func (c *CirLnLs) ShowCirLnLs() {
	temp := c
	if c.Next == nil {
		fmt.Println("環形鏈表為空")
		return
	}
	for {
		if temp.Next != c {
			fmt.Println("Index: ", temp.Index, "Name: ", temp.Name, "Next:", temp.Next)
			temp = temp.Next
		} else {
			fmt.Println("Index: ", temp.Index, "Name: ", temp.Name, "Next:", temp.Next)
			return
		}
	}
}
func main() {
	//創建一隻貓
	c1 := NewCirLnLs(1, "湯姆貓")
	c2 := NewCirLnLs(2, "傑立鼠")
	c3 := NewCirLnLs(3, "米老鼠")
	c4 := NewCirLnLs(4, "飛天鼠")
	c5 := NewCirLnLs(5, "穿山鼠")
	c1.InsertNode(c2)
	c1.InsertNode(c3)
	c1.InsertNode(c4)
	c1.InsertNode(c5)
	c1.ShowCirLnLs()
	fmt.Println("-------刪除任務----------")
	c1, err := c1.DeleteNode(1)
	c1, err = c1.DeleteNode(2)
	c1, err = c1.DeleteNode(3)
	c1, err = c1.DeleteNode(4)
	c1, err = c1.DeleteNode(5)
	// fmt.Println("haha:", c1, c4)
	if err != nil {
		fmt.Println(err)
	} else {
		fmt.Println("-------顯示任務----------")
		c1.ShowCirLnLs()
	}
}
```

作業:

1. 創建一組數組模擬隊列 每隔一定時間[隨機] 給該數組添加一個數

2. 啟動兩個協程 每隔一定到隊列取出數據
3. 在控制台輸出

```
x號協程服務-->> x號客戶
x號協程服務-->> x號客戶
x號協程服務-->> x號客戶
x號協程服務-->> x號客戶
```

使用鎖機制即可



題目二:

1. 創建一組鏈表模擬隊列 每隔一定時間[隨機] 給該數組添加一個數 實現數據入隊列 出隊列 顯示隊列



題目三:

#### 約瑟夫問題

```go
package main

import (
	"errors"
	"fmt"
	"strconv"

	ls "../CircleLinkList"
)

//AddPerson 將玩家加入遊戲 並且返回頭一個玩家
func AddPerson(n int) (head *ls.CirLnLs) {
	name := "a"
	head = ls.NewCirLnLs(1, name+strconv.Itoa(1))
	fmt.Println(head.Name, "加入遊戲了")
	for i := 1; i < n; i++ {
		//創建玩家 並將玩家加入環形鏈表
		d := ls.NewCirLnLs(i+1, name+strconv.Itoa(i+1))
		head.InsertNode(d)
		fmt.Println(d.Name, "加入遊戲了")
	}
	return
}

//CountAndDelete 從選擇的玩家開始 依照約定的跳數報數
//當報數==跳數時，將玩家剔除
//返回剔除的玩家及err
func CountAndDelete(head *ls.CirLnLs, n int) (delNode *ls.CirLnLs, err error) {
	fmt.Println("開始報數:")

	if head == head.Next {
		err = errors.New("剩下一個人在隊裡，遊戲結束了")
		return
	}
	temp := head
	helper := head.NewHelper()
	for i := 0; i < n-1; i++ {
		if temp != temp.Next {
			fmt.Println(temp.Name, "報數:", i+1)
			temp = temp.Next
			helper = helper.Next
		}
	}
	if temp != temp.Next {
		fmt.Println(temp.Name, "報數:", n)
		fmt.Println(temp.Name, "阿~~我死了")
		delNode = temp
		helper.Next = temp.Next

	}
	return
}
func gameStart(total int, hop int) (array []*ls.CirLnLs, last *ls.CirLnLs) {
	if total == 1 {
		fmt.Println("人數不足")
		return
	}
	p := AddPerson(total)
	fmt.Println("加入遊戲的有:")
	p.ShowCirLnLs()
	fmt.Println("每一輪數", hop, "次，數中的人出列")
	last = p
	for {
		del, err := CountAndDelete(last, hop)
		if del != nil {
			array = append(array, del)
		}

		if err != nil {
			fmt.Println("遊戲結數!!!")
			break
		}
		fmt.Println("下一輪由", del.Next.Name, "開始數")
		last = del.Next
	}
	fmt.Println("出局順序為:")
	for i, v := range array {
		fmt.Println(i+1, v.Name)
	}
	fmt.Println("獲勝的人是:", last.Name)
	return
}
func main() {
	gameStart(10, 3)

	// fmt.Println(d.Next)
}

```

### 排序法

#### 冒泡排序法

#### 選擇排序法

1. 第一次從R[0]~R[n-1]中選出最小值 與R[n]交換
2. 逐次從R[0]~R[n-m] 與R[n-m]交換

```go
func SelectSort(s []int) []int {
	//比較頭到尾巴前一個 最後一個不用再比
	for i := 0; i < len(s)-1; i++ {
		max := s[i]
		maxIndex := 0
		//比較i+1以後到尾端的數字
		for j := i + 1; j < len(s); j++ {
			if max < s[j] {
				max = s[j]
				maxIndex = j
			}
		}
		if maxIndex != 0 {
			s[i], s[maxIndex] = s[maxIndex], s[i]
		}
	}
	return s
}
func main() {
	s := []int{13, 5, 444, 77, 46, 93, 2, 9, 11, 6}
	ns := SelectSort(s)
	fmt.Println(ns)
```

#### 插入排序法

把n個待排序的元素看成一個有序表或是一個無序表 開始時有序表中指包含一個元素 無序表中包含有n-1個元素 。排序過程中，每次從無序表中取出第一個元素 把他的排序碼一次與有序表元素的排序碼進行比較 將他插入到有序表中的適當位置 使之成為新的有序表

[23,0,12,56,34]

1. 將23當作一個有序的數組

2. 給0找一個位置 ，插入

3. 先把0保存到一個變量insertVal

將插入的位置用一個便量保存insertindex=0的下標前一個下標

4. 從後開始比較 給insertVal找到位置 插入
5. 在找位置的過程中 有序的數組元素會後移

```go
package main

import "fmt"

// "../ArrayList/Array"
func InsertSort(arr [5]int) {
	//完成第一次 給第二個元素找到合適的位置插入
	for i := 1; i < len(arr); i++ {
		insertVal := arr[i]
		insertIndex := i - 1
		for insertIndex >= 0 && arr[insertIndex] < insertVal {
      //數據後移
			arr[insertIndex+1] = arr[insertIndex] 
      //index再往前找
			insertIndex--                         
		}
		//插入
		if insertIndex+1 != i {
			arr[insertIndex+1] = insertVal
		}
		fmt.Println(arr)
	}
}

func main() {
	s := [5]int{13, 5, 444, 77, 46}

	InsertSort(s)
}

```

#### 快速排序法(Quick Sort O=logn)

```go
func QuickSort(arr []int) []int {

	length := len(arr)
	if length <= 1 {
		return arr
	}
	splitdata := arr[0]
	low := make([]int, 0, 0)  //存儲小的
	high := make([]int, 0, 0) //存儲大的
	mid := make([]int, 0, 0)  //存儲相等的
	mid = append(mid, splitdata)
	for i := 1; i < length; i++ {
		if arr[i] < splitdata {
			low = append(low, arr[i])
		} else if arr[i] > splitdata {
			high = append(high, arr[i])
		} else {
			mid = append(mid, arr[i])
		}
	}
	low, high = QuickSort(low), QuickSort(high)
	myarr := append(append(low, mid...), high...)
	return myarr

}
func main() {
	s := [11]int{13, 5, -100, 57, 46, 9, 6, 31, 20, 45, 68}
	quickSort(0, len(s)-1, &s)
	fmt.Println(s)
}

```

#### 快速排序優化

消耗較少記憶體

```go
//插入排序
func InsertSortX(arr []user, left int, right int) []user {

	if right-left < 1 {
		return arr
	}
	for i := left + 1; i <= right; i++ {
		temp := arr[i]
		for j := i; j > left; j-- {
			if temp.number < arr[j-1].number {
				arr[j] = arr[j-1]
				arr[j-1] = temp
			} else {
				break
			}
		}
	}
	return arr
}

func Swap(arr []user, i int, j int) {
	arr[i], arr[j] = arr[j], arr[i]
}

// left-------lt-----gt---------right
// i=left+1 i從left右邊開始排序
//比較小的放到lt並且lt+=1
//找到比較大的往右放i
//      i

func QuickSortStructX(arr []user, left, right int) []user {
	length := len(arr)
	if length <= 10 {
		arr = InsertSortX(arr, left, right)
		return arr
	}
	val := arr[left]
	i := left + 1
	lt := left
	gt := right + 1
	for i < gt {
		if arr[i].number < val.number {
			Swap(arr, i, lt)
			i++
			lt++
		} else if arr[i].number > val.number {
			Swap(arr, i, gt-1)
			gt--
		} else {
			i++
		}
	}
  //中止條件 右邊界不會比左邊大
	if left < lt-1 {
		QuickSortStructX(arr, left, lt-1)
	}
  //左邊界不會比右邊大
	if right > gt {
		QuickSortStructX(arr, gt, right)
	}
	return arr
}
```

####  堆排序(O=nlogn)

![image-20200610090935293](C:\Users\bited\AppData\Roaming\Typora\typora-user-images\image-20200610090935293.png)

先實作出一個堆積找最大值的方法

```go
func HeapMax(arr []int) []int {
	length := len(arr)
	if length == 1 {
		return arr
	}
	depth := length/2 - 1 //求出深度
	for i := depth; i >= 0; i-- {
		top := i//頂點
		left := 2*i + 1//左子結點
		right := 2*i + 2//右子結點
		if left < length {//防止溢出
			if arr[left] > arr[top] {
				arr[top], arr[left] = arr[left], arr[top]
			}
		}

		if right < length {//防止溢出
			if arr[right] > arr[top] {
				arr[top], arr[right] = arr[right], arr[top]
			}
		}
	}
	return arr
}
```

再將找出的最大值與數列尾部的值交換，並且不斷往前交換

```go
func HeapSort(arr []int) []int {
	length := len(arr)
	for i := length - 1; i > 0; i-- {
		t := HeapMax(arr[:i])
		if t[0] > arr[i] {
			t[0], arr[i] = arr[i], t[0]
		}
	}
	return arr
}

func main() {
	array := []int{1, 9, 5, 6, 6, 7, 3, 4, 2, 4, 1, 8, 10, 9, 4, 1, 2, 8, 0}
	fmt.Println(HeapSort(array))
}
```

#### 奇偶排序

奇數位及偶數位個別做冒泡排序

```go
func OddEvent(arr []int) []int {

	isSorted := false //奇數位 偶數位都不需要排序了

	for !isSorted {
		isSorted = true
		for i := 1; i < len(arr)-1; i += 2 {
			if arr[i] > arr[i+1] {
				arr[i], arr[i+1] = arr[i+1], arr[i]
				isSorted = false
			}
		}
		for i := 0; i < len(arr); i += 2 {
			if arr[i] > arr[i+1] {
				arr[i], arr[i+1] = arr[i+1], arr[i]
				isSorted = false
			}
		}
	}
	return arr
}
```

#### 歸併排序

#### 希爾排序(ShellSort)

適用在多線程



### Stack

先進後出

從stack top進出

棧頂及棧底初始值都是-1

#### 應用場景

1. 子程序的調用 :在跳往子程序之前 會先將下個指令的地址存到堆棧中 直到子程序執行後再將地址取出
2. 處理遞歸調用
3. 表達式的轉換與求值
4. 二叉數的遍歷
5. 圖形的深度優先搜索法



#### 計算機

算法分析

1. 創建兩個棧，一個存數 一個存運算符operStack
2. 讓一個index來掃描表達式
3. 計算表達式是一個字符串
4. 掃描到到數字 將他直接丟到數棧
5. 如果發現是運算符
   1. 如果operStack是一個空棧 直接入棧
   2. 如果發現operStack棧頂的運算符的優先級大於等於當前準備入棧的運算符的優先級，就從將operStack做pop，數棧pop出兩個值，做計算，並且將計算結果再Push到數棧，符號再入operStack
   3. 否則運算符直接入棧
6. 如果掃描到結尾，則從數棧中彈出兩個數 符號棧彈出一個符號 執行運算 運算的結果入數棧

```go
package main

import (
	"fmt"
	"strconv"

	st "../Stack"
)

//判斷一個字符是不是運算符(* + - /) 42 43 45 47
func IsOperator(val int) bool {

	if val == 42 || val == 43 || val == 45 || val == 47 {
		return true
	} else {
		return false
	}
}

//運算方法
func Cal(num1, num2 int, oper int) (res int) {
	// num1 = num1 - 48
	// num2 = num2 - 48
	switch oper {
	case 42:
		res = num2 * num1
	case 43:
		res = num2 + num1
	case 45:
		res = num2 - num1
	case 47:
		res = num2 / num1
	default:
		fmt.Println("運算符錯誤")
	}
	return res
}

//判斷優先級 (*, / 1) (+, - 0)
func operPriority(oper int) int {
	res := 0
	if oper == 42 || oper == 47 {
		res = 1
	} else if oper == 43 || oper == 45 {
		res = 0
	}
	return res
}

func main() {
	numStack := st.NewStack()
	operStack := st.NewStack()

	exp := "300+30*6-4-6"

	//定義一個index幫助掃描
	index := 0
	//為了配合運算
	num1 := 0
	num2 := 0
	oper := 0
	result := 0
	keepNum := ""
	for {
		//增加一個邏輯
		//處理多位數問題
		ch := exp[index : index+1] //從exp取出charactor
		temp := int([]byte(ch)[0])

		if IsOperator(temp) { //如果是符號
			if operStack.Top == -1 { //如果是空
				operStack.Push(temp)
			} else {
				//判斷Stack內部的符號優先級
				if operPriority(operStack.Data[operStack.Top]) > operPriority(temp) {
					num1, _ = numStack.Pop()
					num2, _ = numStack.Pop()
					oper, _ = operStack.Pop()
					result = Cal(num1, num2, oper)
					numStack.Push(result)
					operStack.Push(temp)
				} else {
					operStack.Push(temp)
				}
			}

		} else { //如果是數字
			//處理多位數的思路
			//先定義一個變數keepnum string做拼接
			keepNum += ch
			//每次要向index的後面字符測試一下 看看是不是運算符
			if index == len(exp)-1 { //如果已經到表達是最後 直接將keepNum做拼接
				val, _ := strconv.ParseInt(keepNum, 10, 64)
				numStack.Push(int(val))
			} else {
				//向後探一位
				if IsOperator(int([]byte(exp[index+1 : index+2])[0])) {
					val, _ := strconv.ParseInt(keepNum, 10, 64)
					numStack.Push(int(val))
					keepNum = ""
				}
			}

		}
		//判斷是否繼續掃描
		if index == len(exp)-1 {
			break
		} else {
			index++
		}
	}
	for {
		if operStack.Top == -1 {
			break
		}
		num1, _ = numStack.Pop()
		num2, _ = numStack.Pop()
		oper, _ = operStack.Pop()
		result = Cal(num1, num2, oper)
		numStack.Push(result)
	}
	//如果算法沒有問題 表達是也是正確 結果就是numStack最後的數
	res, _ := numStack.Pop()
	fmt.Println("表達式結果", exp, "=", res)
}

```

### 遞歸

遞歸需要參數能夠收縮

八皇后問題 

漢諾塔

階乘問題

迷宮問題

紅黑樹

```go
package main

import "fmt"

type PazzleMap struct {
	Row int
	Col int
	Map [8][7]int
}

func NewPazzleMap() *PazzleMap {
	p := new(PazzleMap)
	p.Col = len(p.Map)
	p.Row = len(p.Map[0])
	return p
}

func (p *PazzleMap) ShowPazzle() {
	for i := 0; i < len(p.Map); i++ {
		for j := 0; j < len(p.Map[i]); j++ {
			fmt.Print(p.Map[i][j], " ")
		}
		fmt.Println()
	}
}

//編寫一個函數 讓老鼠找路
//傳入地圖及起始點
func (p *PazzleMap) SetWay(i int, j int) bool {
	if p.Map[6][5] == 2 {
		fmt.Println("找到路了")
		return true
	} else {
		//繼續找
		if p.Map[i][j] == 0 { //如果給定的點不是牆而且沒有探測過
			//假設此點可以通 先將其設為2 但需要探測 上下左右
			//改成下右上左
			p.Map[i][j] = 2
			if p.SetWay(i+1, j) {
				return true
			} else if p.SetWay(i, j+1) {
				return true
			} else if p.SetWay(i-1, j) {
				return true
			} else if p.SetWay(i, j-1) {
				return true
			} else {
				p.Map[i][j] = 3
				return false
			}

		} else { //這個點不能探測
			return false
		}
	}

}

func main() {
	//規則
	//1. 如果元素的值為1 就是牆
	//2. 如果元素為0 表示還沒走過的格子
	//3. 如果元素為2 表示是通路
	//4. 如果元素為3 表示走過 但是是死路
	p := NewPazzleMap()

	//先把地圖的最上和最下設置為1
	for i := 0; i < 7; i++ {
		p.Map[0][i] = 1
		p.Map[7][i] = 1
	}
	//把最左和最後設為1
	for i := 0; i < 8; i++ {
		p.Map[i][0] = 1
		p.Map[i][6] = 1
	}
	p.Map[3][1] = 1
	p.Map[3][2] = 1
	p.ShowPazzle()
	p.SetWay(1, 1)
	p.ShowPazzle()
}

```

球和籃子

### HASH

* 

基本上是一個鏈表 透過鏈表將資料關連起來 透過一個映射關係存放紀錄的數組就叫做hash表



實際需求:

當有員工來報到 需要紀錄他的ID 姓名 電話地址等基本資料 不可用資料庫 要透過ID來訪問這個資料 越快越好 記憶體耗用越小越好

添加時 保證按照雇員的ID從低到高插入

* 按ID查詢

思路分析:

* 先建一個結構體
* 包含七個鏈表

![image-20200525190341357](C:\Users\bited\AppData\Roaming\Typora\typora-user-images\image-20200525190341357.png)

```go
package main

import (
	"fmt"
	"os"
)

//使用hash來創建一個一存放員工資料的數據結構

type Emp struct {
	Id   int
	Name string
	Next *Emp
}

//方法待定

//定義EmpLink
//這裡的Emplinl不帶表頭
//第一個節點就存放雇員
type EmpLink struct {
	Head *Emp
}

//添加員工的方法 保證添加時 編號從小到大
func (empl *EmpLink) Insert(emp *Emp) {
	cur := empl.Head   //這是一個輔助指針
	var pre *Emp = nil //這是一個輔助指針 pre始終在cur前面
	//如果當前的EmpLink就是一個空鏈表
	if cur == nil {
		empl.Head = emp
		return
	}
	//如果不是空鏈表 給emp找到對的位置並插入
	//思路是 讓cur和emp比較 讓pre保持在cur前面
	for {
		if cur != nil {
			if cur.Id > emp.Id && empl.Head == cur {
				emp.Next = cur
				empl.Head = emp
				return
			}
			if cur.Id > emp.Id {
				break
			}
			pre = cur
			cur = cur.Next
		} else {
			break
		}
	}
	//退出時 決定是否在鏈表最後
	pre.Next = emp
	emp.Next = cur
}

//查找
func (empl *EmpLink) FindByID(id int) *Emp {
	if empl.Head == nil {
		return nil
	}
	temp := empl.Head
	for {
		if temp.Id == id && temp != nil {
			return temp
		} else if temp == nil {
			return nil
		} else {
			temp = temp.Next
		}
	}

}

//顯示linkLisr
func (empl *EmpLink) ShowLink(no int) {
	if empl.Head == nil {
		fmt.Printf("此鏈表%d為空\n", no+1)
		return
	}
	temp := empl.Head
	fmt.Printf("此鏈表%d內容:", no+1)
	for {
		if temp != nil && temp.Next != nil {
			fmt.Printf("雇員id=%d 名字=%s => ", temp.Id, temp.Name)
			temp = temp.Next
		} else if temp != nil && temp.Next == nil {
			fmt.Printf("雇員id=%d 名字=%s\n", temp.Id, temp.Name)
			break
		} else {
			fmt.Println()
			break
		}
	}
}

type HashTable struct {
	LinkArr [7]EmpLink
}

//給HashTable 編寫inset雇員的方法
func (h *HashTable) Insert(emp *Emp) {
	//使用散列函數確定將該雇員添加到哪個鏈表
	linkNo := h.HashFun(emp.Id)
	//使用對應的鏈表添加
	h.LinkArr[linkNo].Insert(emp)
}

//編寫方法顯示hash表內所有雇員
func (h *HashTable) ShowAll() {
	for i := 0; i < len(h.LinkArr); i++ {
		h.LinkArr[i].ShowLink(i)
	}
}

//查找雇員
func (h *HashTable) FindById(id int) (emp *Emp) {
	l := h.HashFun(id)
	return h.LinkArr[l].FindByID(id)
}

//編寫一個散列方法
func (h *HashTable) HashFun(id int) int {
	return id % 7 //得到一個值 也就是鏈表的下標
}

func main() {

	h := HashTable{}
	for {
		fmt.Println(`
==============雇員系統菜單================
1. 添加雇員
2. 顯示雇員
3. 查找雇員
4. 退出系統
請輸入選擇: `)

		var key string
		var id int
		var name string
		fmt.Scan(&key)
		switch key {
		case "1":
			fmt.Println("輸入雇員id:")
			fmt.Scan(&id)
			fmt.Println("輸入雇員名字:")
			fmt.Scan(&name)
			emp := &Emp{
				Id:   id,
				Name: name,
			}
			h.Insert(emp)
		case "2":
			h.ShowAll()
		case "3":
			fmt.Println("輸入雇員Id")
			fmt.Scan(&id)
			emp := h.FindById(id)
			if emp != nil {
				fmt.Println("Id", id, "是", emp.Name)
			} else {
				fmt.Println("查無此人")
			}
		case "4":
			os.Exit(1)
		default:
			fmt.Println("輸入有誤")
		}
	}
}

```

### 

