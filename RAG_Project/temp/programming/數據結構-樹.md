# 數據結構-樹

## 平衡樹

## 2-3查找樹

2結點 含有一個鍵(其對應的值)和兩條鏈，左鏈指向2-3樹中的鍵 都小於該結點 右鍵指向的2-3查找樹中的鍵都大於該結點

3-結點 含有兩個鍵(其對應的值)和三條鏈，左鏈指向2-3樹中的鍵 都小於該結點 中鏈接指向的鍵都位於該結點的兩鍵之間 右鍵指向的2-3查找樹中的鍵都大於該結點

### 插入

#### 向2-結點中插入新鍵

#### 向一顆只有3-結點的樹中插入新鍵

![image-20200526080102376](C:\Users\bited\AppData\Roaming\Typora\typora-user-images\image-20200526080102376.png)

#### 向一顆父結點為2-結點的3-結點的樹中插入新鍵

![image-20200526080118623](C:\Users\bited\AppData\Roaming\Typora\typora-user-images\image-20200526080118623.png)

![image-20200526080226607](C:\Users\bited\AppData\Roaming\Typora\typora-user-images\image-20200526080226607.png)

#### 向一個父結點為3-結點的3-結點插入新鍵

![image-20200526080557186](C:\Users\bited\AppData\Roaming\Typora\typora-user-images\image-20200526080557186.png)

![image-20200526080645351](C:\Users\bited\AppData\Roaming\Typora\typora-user-images\image-20200526080645351.png)

![image-20200526080745224](C:\Users\bited\AppData\Roaming\Typora\typora-user-images\image-20200526080745224.png)

#### 插入根節點

![image-20200526080814597](C:\Users\bited\AppData\Roaming\Typora\typora-user-images\image-20200526080814597.png)

![image-20200526081017589](C:\Users\bited\AppData\Roaming\Typora\typora-user-images\image-20200526081017589.png)

### 2-3樹的性質

* 任意空鏈接到根節點的路徑長度都是相等的

* 4-節點遍換為3-節點時 樹的高度不會變化 只有當根節點是臨時的4-節點 分解根節點時 樹高+1

* 2-3樹與普通二叉樹最大區別在於 普通的二叉查找樹是自頂向下生長 而2-3樹是自底部向上生長

### 2-3樹的實現

直接實現2-3樹較為複雜

* 需要處理不同的節點類型
* 需要多次比較操作來將節點下移
* 需要上移來拆分4-節點
* 拆分4-節點的情況有很多種

## 紅黑樹

紅黑樹是對2-3樹進行編碼 宏ㄟ樹背後的基本思想是用標準的二叉查找樹和一些額外的信息來表示2-3樹

鏈結分為兩種類型:

* 紅鏈接: 將兩個2-結點連接起來構成一個3-結點
* 黑鏈接: 2-3樹中的普通鏈接

![image-20200526082058771](C:\Users\bited\AppData\Roaming\Typora\typora-user-images\image-20200526082058771.png)

### 紅黑樹的定義

* 紅鏈接均為左鏈接
* 沒有任何一個節點同時和兩條紅鏈接相連
* 該是樹完美黑色平衡的 任意空鏈接到根結點的路徑上黑鏈接樹量相同

![image-20200526082356995](C:\Users\bited\AppData\Roaming\Typora\typora-user-images\image-20200526082356995.png)

### 紅黑樹結點API

| 類名     | Node<key,value>                                              |
| -------- | ------------------------------------------------------------ |
| 構造方法 | Node(Key key, Value value, Node left, Node right, boolean color):創鍵Node對像 |
| 成員變量 | 1. Node left: 紀錄左子結點 <br/>2. Node right 紀錄右子結點<br/>3. key key存儲體<br/>4. Value value存儲值<br/>5. boolean color由其父結點指向他的鏈接顏色 |

### 平衡化

再對紅黑樹進行一些增刪改查後 很有可能會出現紅色的右鏈接

#### 左旋

1. 讓s的左子結點變為e的右子結點 e.right=s.left;
2. 讓e成為s的左子結點 s.left=e
3. 讓e的color屬性變為s的color屬性值 e.color=s.color
4. 讓e的color屬性變為RED e.color=true

![image-20200526083451558](C:\Users\bited\AppData\Roaming\Typora\typora-user-images\image-20200526083451558.png)

#### 右旋

當某個節點的左子節點是紅色 且左子結點的左子結點也是紅色

1. 讓e的右子結點成為s的左子結點 s.left=e.right
2. 讓s成為e的右子結點e.right=s
3. 讓e的color變為s的color屬性值e.color=s.color
4. 讓s的color為red

![image-20200526084545426](C:\Users\bited\AppData\Roaming\Typora\typora-user-images\image-20200526084545426.png)

### 紅黑樹的插入

#### 向單個2-節點中插入新鍵

* 如果新鍵小於當前節點的鍵 我們只需要新增一個紅色節點即可 新的紅黑樹和單個3-節點完全等價

![image-20200526084935695](C:\Users\bited\AppData\Roaming\Typora\typora-user-images\image-20200526084935695.png)

* 如果新鍵大於當前節點的鍵 那麼新增的紅色節點將會產生一條紅色的右鏈接 此時我們需要通過左旋 把紅色右鏈接變成左鏈接 插入操作才算完成 形成的新的紅黑樹依然和3-節點等價 其中含有兩個鍵 一條紅色鏈接

![](C:\Users\bited\AppData\Roaming\Typora\typora-user-images\image-20200526085242808.png)

#### 向底部的2-節點插入新鍵

![image-20200526085427053](C:\Users\bited\AppData\Roaming\Typora\typora-user-images\image-20200526085427053.png)

#### 顏色反轉

![image-20200526085507436](C:\Users\bited\AppData\Roaming\Typora\typora-user-images\image-20200526085507436.png)

#### 向一顆雙鍵樹(即一個3-節點)中插入新鍵

![image-20200526085651206](C:\Users\bited\AppData\Roaming\Typora\typora-user-images\image-20200526085651206.png)

* 新鍵小於源樹中的兩個鍵

![image-20200526085921945](C:\Users\bited\AppData\Roaming\Typora\typora-user-images\image-20200526085921945.png)

![](C:\Users\bited\AppData\Roaming\Typora\typora-user-images\image-20200526090000094.png)

* 新鍵介於兩個源樹中兩個鍵之間

![image-20200526090035950](C:\Users\bited\AppData\Roaming\Typora\typora-user-images\image-20200526090035950.png)

![image-20200526090113872](C:\Users\bited\AppData\Roaming\Typora\typora-user-images\image-20200526090113872.png)

#### 根節點的顏色總是黑色

#### 向樹的底部的3-節點插入新鍵

![image-20200526090437451](C:\Users\bited\AppData\Roaming\Typora\typora-user-images\image-20200526090437451.png)

![image-20200526090451010](C:\Users\bited\AppData\Roaming\Typora\typora-user-images\image-20200526090451010.png)

![image-20200526090508065](C:\Users\bited\AppData\Roaming\Typora\typora-user-images\image-20200526090508065.png)

![image-20200526090526585](C:\Users\bited\AppData\Roaming\Typora\typora-user-images\image-20200526090526585.png)

### 紅黑樹的API設計

| 類名     | RedBlackTree                                                 |
| -------- | ------------------------------------------------------------ |
| 構造方法 | RedBlackTree()創建RedBlackTree對像                           |
| 成員方法 | 1. isRed (x Node) bool判斷當前節點的父指像鏈接是否為紅色<br>2. rotateLedt(h Node) *Node左旋調整<br>3. rotateRight(h Node) *Node右旋調整<br>4. flipColor(h Node)顏色反轉<br>5. Put( key Key, val Value) 在整個樹上完成插入操作<br>6. NodePut((h Node, key Key, val Value)在指定樹中 完成插入操作 並返回添加元素後新的樹<br>7. Get(key Key) 根據key從樹中找出對應的值<br>8. Get(x Node, key Key)從指定的樹x中 找出key對應的值<br>9. size() int獲取樹中元素的個數 |
| 成員變量 | 1. Node root 紀錄根節點<br>2. int N紀錄樹中元素的個數<br>3. final bool RED 紅色鏈接標示<br>4. final bool BLACK 黑色鏈接標示 |

```go
package main

import (
	"fmt"
	"os"
)

type RBNode struct {
	Key   int
	Value interface{}
	Left  *RBNode
	Right *RBNode
	//true 代表紅色 false is black
	Color bool
	//節點中的元素數
}

type RBTree struct {
	Head *RBNode
	N    int
}

func NewRBTree() *RBTree {
	tree := new(RBTree)
	tree.N = 0
	return tree
}

//NewRBNode make a new RBNode
func NewRBNode(key int, val interface{}) *RBNode {
	n := new(RBNode)
	n.Key = key
	n.Value = val
	return n
}

func (tree *RBTree) Put(newnode *RBNode) *RBTree {
	tree.Head = tree.Head.PutNode(newnode)
	//新增一顆新樹
	newtree := NewRBTree()
	newtree.Head = newnode
	tree.N++
	return newtree
}

func (n *RBNode) PutNode(newnode *RBNode) *RBNode {
	fmt.Println(n)
	if n == nil {
		newnode.Color = true
		return newnode
	}

	//比較鍵值
	if newnode.Key < n.Key {
		fmt.Println("加入左邊")
		n.Left = n.Left.PutNode(newnode)
	} else if n.Key < newnode.Key {
		fmt.Println("加入右邊")
		n.Right = n.Right.PutNode(newnode)
	} else {
		n.Value = newnode.Value
	}

	fmt.Printf("要左旋嗎?\n")
	//判斷是否要左旋 當左子結點顏色為黑色 右子結點顏色為紅色
	//左邊可能為空
	if n.Left != nil {
		if (!n.Left.IsRed()) && (n.Right.IsRed()) {
			fmt.Println("要左旋", n.Key, "左", n.Left, "右", n.Right)
			return n.RotateLeft()
		}
	} else { //左邊可能為空
		if n.Right.IsRed() {
			fmt.Println("要左旋", n.Key, "左", n.Left, "右", n.Right)
			return n.RotateLeft()
		}
	}

	//或是右旋
	fmt.Printf("要右旋嗎?\n")
	if n.Left != nil {
		if n.Left.Left != nil {
			if (n.Left.IsRed()) && (n.Left.Left.IsRed()) {
				fmt.Println("要右旋", n.Key, "左", n.Left, "右", n.Right)
				n = n.RotateRight()
				//右旋以後顏色需要反轉
				if (n.Left.IsRed()) && (n.Right.IsRed()) {
					fmt.Println("顏色反轉囉", n.Key, "左", n.Left, "右", n.Right)
					n.ColorFlip()
					return n
				}
			}
			return n
		}
	}
	fmt.Printf("顏色要反轉嗎?\n")
	if n.Left != nil && n.Right != nil {
		if (n.Left.IsRed()) && (n.Right.IsRed()) {
			fmt.Println("顏色反轉囉", n.Key, "左", n.Left, "右", n.Right)
			n.ColorFlip()
			return n
		}
	}

	return n
}

func (tree *RBTree) Size() int {
	return tree.N
}

func (n *RBNode) IsRed() bool {
	return n.Color
}

// RotateLeft 將左旋的Node輸入 返回新的子節點
func (n *RBNode) RotateLeft() *RBNode {
	x := n.Right
	n.Right = x.Left
	x.Left = n
	x.Color = n.Color
	n.Color = true
	return x
}

func (n *RBNode) RotateRight() *RBNode {
	x := n.Left
	n.Left = x.Right
	x.Right = n
	x.Color = n.Color
	n.Color = true
	return x
}

func (n *RBNode) InfixShow() {
	if n != nil {
		n.Left.InfixShow()
		fmt.Printf("%p Key:%d Value=%s Color=%v\n", n, n.Key, n.Value, n)
		n.Right.InfixShow()
	}
}
func (tree *RBTree) Show() {
	if tree.Head != nil {
		fmt.Println("樹根是", tree.Head.Key)
	}

	tree.Head.InfixShow()
}

//ColorFlip 顏色反轉
func (n *RBNode) ColorFlip() {
	n.Right.Color = false
	n.Left.Color = false
	n.Color = true
}

func main() {
	tree := NewRBTree()

	var k string
	key := 0
	// var val string
	var name string
	for {
		fmt.Println(`
  =======水滸英雄表======
  1. 添加英雄
  2. 顯示英雄
  3. 查詢英雄
  4. 退出
  請輸入你的選擇:
  `)
		fmt.Scan(&k)
		switch k {
		case "1":
			fmt.Println("請輸入英雄的編號:")
			fmt.Scan(&key)
			fmt.Println("請輸入英雄名稱:")
			fmt.Scan(&name)
			h := NewRBNode(key, name)
			tree.Put(h)
		case "2":
			tree.Show()
		case "3":
			fmt.Println("請輸入要搜尋的英雄編號:")
			fmt.Scan(&key)
			fmt.Println("你找的英雄是:", key)
		case "4":
			os.Exit(1)
		}
	}
}
```

## B-樹

B樹中允許一個節點中包含多個key 可以是3個4個5個 我們使用參數M來構造一個B樹 可以把他稱作是M階的B樹

* 每個節點最多M-1個Key 
* 每個結點最多能有M個子節點
* 根節點至少有兩個子節點

在實際應用中 階數通常較大 通常大於100 所以即使存放大量數據 B樹高度仍然比較小 這樣在某些應用場景就可以體現出他的優勢

### B樹存儲數據

若參數M選擇為5

在節點中 必須升幂排序

文件系統就是用B數來實現使用1024\*1024\*1024三層的B數就可以容納1個億的字節



## B+樹

#### B+樹和B樹的比較

1. B+樹的非葉子節點不包含真正的數據 只當做索引使用 因此在相同內存的情況下 能夠存放更多的key
2. B+樹的葉子節點都是相連的 因此對整棵樹的便利只要一次線性的遍歷葉子節點即可。但是B樹需要對每一層的遞歸遍歷

##### B樹的優點在於:

每一個節點都包含key和value 因此我們跟據key查找value時 只需要找到key所在的位置就能找到value 但是B+樹需要每一次都找到最大深度才能找到value

### B+樹在資料庫中的應用

透過建立索引 放在B+樹中加快數據的查詢

### 併查集

併查集是一種樹型的數據結構 可以高效的進行如下操作:

* 查詢元素p和q是否同一組

* 合併元素p和元素q所在的組

![image-20200526163930252](C:\Users\bited\AppData\Roaming\Typora\typora-user-images\image-20200526163930252.png)

#### 併查集的結構



* 每個元素都唯一的對應一個節點

* 每一組數據中的多個元素都在同一棵樹中

* 一個組中的數據對應樹和另外一個組中的樹之間沒有任何聯繫

* 元素在樹中並沒有子父級關係的硬性要求

![image-20200526163602153](C:\Users\bited\AppData\Roaming\Typora\typora-user-images\image-20200526163602153.png)

### 併查集API

| 類名     | UF                                                           |
| -------- | ------------------------------------------------------------ |
| 構造方法 | UF(int N)                                                    |
| 成員方法 | 1. count<br>2. connected (intp, int q)判斷併查集中元素p和元素q是否在同一分組中<br>3. find(int p) 元素p所在分組的標示符<br>4. union(int p , int q) 把p元素所在分組和q所在分組合併 |
| 成員變量 | 1. eleAndGroup紀錄節點元素和該元素所在分組的標示<br>2. count 紀錄併查集中數據的分組個數 |

