# 數據結構-圖

點 線構成

地圖

電路板

### 定義

由一組頂點和能夠將頂點相連的邊組成

#### 特殊的圖

1. 自環
2. 平行邊:連接同一對頂點的邊



### 圖的分類

* 無向圖: 僅連接 
* 有向圖: 連接且有方向性

#### 無向圖

**相鄰頂點**

當兩個頂點通過一條邊相連時 我就這兩個頂點相鄰

**度**

某個頂點的度 就是與該頂點相依附的頂點個數

**子圖**

**路徑**

由邊順序連接的一系列頂點組成

**環**

至少有一條邊且終點和起點相同的路徑

**連通圖**

如果圖中任意一個頂點都存在一條路徑到另外一個頂點

**連通子圖**

一個非連通圖由若干連通的部分組成 每一個連通的部分都可以稱為該圖的聯通子圖

### 圖的存儲結構

1. 圖中所有的頂點
2. 所有連接頂點的邊

#### 鄰接矩陣

1. 使用一個V*V的二維數組int\[V\]\[V\] adj把索引看作是頂點
2. 如果頂點V和頂點W相聯 我們只需要將adj\[v\]\[w\]的值設為1否則設為0即可

![image-20200527145006073](C:\Users\bited\AppData\Roaming\Typora\typora-user-images\image-20200527145006073.png)

#### 鄰接表

1. 使用一個大小為V的數組Queue[V]adj 把索引看作是頂點
2. 每個索引處adj[v]存儲了一個隊列 該隊列中存儲的是所有與該頂點相鄰的其它頂點

![image-20200527145534836](C:\Users\bited\AppData\Roaming\Typora\typora-user-images\image-20200527145534836.png)

### 圖的API

| 類名     | Graph                                                        |
| -------- | ------------------------------------------------------------ |
| 構造方法 | Graph(int V)創建一個包含V個頂點但不包含邊的圖                |
| 成員方法 | 1. V()獲取圖中頂點的數量<br>2. E()獲取圖中邊的數量<br>3. addEdge(v int,w int)向圖中添加一條邊v-w<br>4. Queue adj(v int)獲取和頂點v相鄰的所有頂點 |
| 成員變量 | int V 紀錄頂點數量<br>intE 紀錄邊數量<br>Queue[]adj鄰接表    |

### 代碼實現

```go
package main

import "fmt"

type Node struct {
	Key     int
	Adjs    []*Node
	InGraph *Graph
}

type Graph struct {
	//頂點數量
	V     int
	E     int
	Nodes []*Node
}

func NewGraph() *Graph {
	g := new(Graph)
	return g
}

func NewNode(key int) *Node {
	n := new(Node)
	n.Key = key
	return n
}

func (g *Graph) CountV() int {
	return g.V
}
func (g *Graph) CountE() int {
	return g.E
}
func (g *Graph) AddNode(n *Node) {
	for _, v := range g.Nodes {
		if n.Key == v.Key { //如果節點值重複就更新
			v.Key = n.Key
			return
		}
	}
	g.Nodes = append(g.Nodes, n)
	n.InGraph = g
	g.V++
}

func (g *Graph) AddEdge(n1 *Node, n2 *Node) {
	//先判斷點是否在地圖中
	if n1.InGraph == g && n2.InGraph == g {
		n1.Adjs = append(n1.Adjs, n2)
		n2.Adjs = append(n2.Adjs, n1)
		g.E++
	}
	if n1.InGraph != g {
		fmt.Println(n1.Key, "不在地圖中")
	}
	if n2.InGraph != g {
		fmt.Println(n2.Key, "不在地圖中")
	}
}
func (g *Graph) ShowGraph() {
	fmt.Println("圖中的節點有:")
	for _, v := range g.Nodes {
		fmt.Printf("%d ", v.Key)
		v.ShowNeighbor()
	}
}
func (n *Node) ShowNeighbor() {
	if n.Adjs == nil {
		fmt.Printf("%d沒有鄰居\n", n.Key)
		return
	}
	fmt.Printf("%d的鄰居有:[", n.Key)
	for _, v := range n.Adjs {
		fmt.Printf("%d", v.Key)
	}
	fmt.Println("]")
}
func main() {
	g := NewGraph()
	n1 := NewNode(1)
	n2 := NewNode(2)
	n3 := NewNode(3)
	n4 := NewNode(4)
	n5 := NewNode(5)
	g.AddNode(n1)
	g.AddNode(n2)
	g.AddNode(n3)
	g.AddNode(n4)
	g.AddNode(n5)
	g.AddEdge(n1, n2)
	g.ShowGraph()

}
```

### 圖的搜索

#### 深度優先

![image-20200527185527611](C:\Users\bited\AppData\Roaming\Typora\typora-user-images\image-20200527185527611.png)

**API設計**

| 類名     | DepthFirstSearch                                             |
| -------- | ------------------------------------------------------------ |
| 構造方法 | DepthFirstSearch(g *Graph, s int) 構造深度優先搜索對像 使用深度優先搜索 找出G圖中s頂點的所有相通頂點 |
| 成員方法 | 1. DFS(g *Graph, v int): 使用深度優先搜索找出G圖中v頂點所有相通頂點<br>2. Marked( w int): 判斷w頂點與s頂點是否相通<br>3. Count() 獲取與頂點s相通的所有頂點的總數<br> |
| 成員變量 | 1. Marked: 索引代表頂點 值表示當前頂點是否已經被搜索<br>2. Count紀錄有多少頂點與s頂點相通 |

程式碼

```go
package main

import (
	"fmt"

	"../Graph"
	rbt "../RedBlackTree"
)

type DepFirstSearch interface {
	DFS(s *Graph.Node)
}

type DFSResult struct {
	//索引表示node的key值 值表示
	Marked *rbt.RBTree
	Count  int
}

func FindDFS(g *Graph.Graph, node *Graph.Node) *DFSResult {
	if node.InGraph != g {
		fmt.Printf("Node is not in this graph.")
		return nil
	}
	d := new(DFSResult)
	d.Marked = rbt.NewRBTree()
	rbnode := rbt.NewRBNode(node.Key, node)
	d.Marked.Put(rbnode)
	d.DFS(node)
	return d
}

func (d *DFSResult) DFS(s *Graph.Node) {
	for _, node := range s.Adjs {
		rbnode := rbt.NewRBNode(node.Key, node)
		if d.Marked.Find(rbnode) == nil {
			d.Marked.Put(rbnode)
			d.DFS(node)
		}
	}
	d.Count++
}

func (d *DFSResult) ShowSearch() {
	fmt.Println("透過紅黑樹儲存路徑: 相通的點如下:")
	d.Marked.Show()
}

func main() {
	g := Graph.NewGraph()
	// var g.Nodes [100]*Graph.Node
	for i := 0; i < 100; i++ {
		node := Graph.NewNode(i)
		g.AddNode(node)
	}
	g.AddEdge(g.Nodes[0], g.Nodes[1])
	g.AddEdge(g.Nodes[0], g.Nodes[2])
	g.AddEdge(g.Nodes[0], g.Nodes[3])
	g.AddEdge(g.Nodes[3], g.Nodes[5])
	g.AddEdge(g.Nodes[5], g.Nodes[10])
	g.AddEdge(g.Nodes[90], g.Nodes[99])
	g.AddEdge(g.Nodes[99], g.Nodes[80])
	g.AddEdge(g.Nodes[50], g.Nodes[51])
	result := FindDFS(g, g.Nodes[90])
	result.ShowSearch()
}
```

#### 廣度優先

| 類名     | BreadFirstSearch                                             |
| -------- | ------------------------------------------------------------ |
| 構造方法 | BreadFirstSearch(g Graph, s Node)構造廣度優先搜索對像使用廣度優先搜索找出G圖中所有的相鄰頂點 |
| 成員方法 | 1. BFS(g Graph, v Node)使用廣度優先搜索找出G圖中V頂點的所有相鄰頂點<br>2. Marked(w Node) 判斷頂點w是否與s頂點相通<br>3.Count()獲取與頂點s相通的所有頂點總數 |
| 成員變量 | 1. Marked索引表示頂點 值表示當前頂點是否已經被搜索<br>2. count 紀錄有多少個頂點s頂點來相通<br>3. Queue |

### 路徑搜索

| 類名     | DepthFirstPaths                                              |
| -------- | ------------------------------------------------------------ |
| 構造方法 | DepthFirstPaths                                              |
| 成員方法 | 1. DFS 使用深度優先搜索找出G圖中v頂點的所有相鄰頂點<br>2. hasPathTo(v Node): 判斷頂點s與頂點v是否存在路徑<br>3. PathTo(v Node)使用Stack來儲存s到v的路徑 |
| 成員變量 | 1. Marked<br>2. s : 起點<br>3. edgeTo: 索引代表頂點 值代表起點s到當前路徑上的最後一個頂點<br> |

```go
//先進行深度優先搜索

//使用EdgeTo數列表示起點到終點的路徑順序

```

edgeTo是一個很重要的變數，用來存路徑上每個頂點的上一個頂點

### 有向圖

#### 定義及術語

**定義:**

有向圖是依附具有方向性的圖 是由一組頂點和一組有方向的邊組成 每條方向的邊都連著一隊有序的頂點

**出度:**

由某個頂點指出的邊的個數稱為該頂點的出度

**入度:**

由某個頂點指入的邊的個數稱為該頂點的入度

**有向路徑:**

由一系列頂點組成 對於其中的每個頂點都存在一條有向邊 從他指向序列中的下一個頂點

**有向環:**

一條至少含有一條邊 且起點和終點相同的有向路徑

**一個有向圖中兩個頂點v和w可能存在以下四種關係**

1. 沒有邊相連
2. 存在從v到w的邊v->w
3. 存在從w到v的邊w->v
4. 既存在w到v 也存在v到w2的邊 即雙向連接