# 資料搜尋

## 二元查找法

```go
func BinarySearch(arr []int, data int) int {
	left := 0
	right := len(arr) - 1 //最上面和最上面
	for left <= right {
		mid := (left + right) / 2
		if arr[mid] > data {
			right = mid - 1
		} else if arr[mid] < data {
			left = mid - 1
		} else {
			return mid
		}
	}
	return -1
}
```



## 中值法

```go
func RatioSearch(arr []int, data int) int {
	length := len(arr)                  //100
	alllength := arr[length-1] - arr[0] //
	mid := data - arr[0]
	i := float64(length) * (float64(mid) / float64(alllength))
	fmt.Println(i)
	time := 1
	for i < float64(length-1) {
		fmt.Printf("i:%v,第%d次查找:\n", i, time)
		if arr[int(i)] == data {
			return arr[int(i)]
		}
		time++
		i += 1.0
	}
	return -1
}
```

## 菲波納契查找

├─────f(k-1)-1────────────────────┼─────f(k-2)──────┤

└──────────────────────f(k)─────────────────────┘

```go
//先找出最接近但是大於搜尋數列的長度的菲波納契數列
//1 1 2 3 5 8 13 21 34 55 89
//每一段切割都接近於黃金比例切割
func makeFabArray(arr []int) (fabArr []int, l int) {
	length := len(arr)
	fabArr = make([]int, 2)

	fabArr[0] = 1
	fabArr[1] = 1

	for k := 2; fabArr[k-1] < length; k++ {
		fabArr = append(fabArr, fabArr[k-1]+fabArr[k-2])
	}
	return fabArr, len(fabArr)
}

func fabSearch(arr []int, val int) int {
	fabArr, l := makeFabArray(arr)
	fmt.Println(fabArr)
	fillLen := fabArr[l-1] - len(arr)
	for i := 0; i < fillLen; i++ {
		arr = append(arr, arr[len(arr)-1])
	}
	fIdx := l - 2
	low := 0
	mid := 0
	high := len(arr) - 1

	for low < high {
		

		mid = low + fabArr[fIdx] - 1
		fmt.Println("mid:", mid, "arr[mid]:", arr[mid])
		if arr[mid] < val {
			
			fIdx -= 2
			low = mid + 1
		} else if arr[mid] > val {
			
			fIdx--
			high = mid - 1

		} else {
			if mid > high {
				return high
			}
			return mid
		}
	}
  //搜尋值在邊界上面
	if arr[low] == val {
		return low
	}
	if arr[high] == val {
		return high
	}
	return -1
}
func main() {
	arr := make([]int, 10000)
	for i := 0; i < 10000; i++ {
		arr[i] = i
	}
	fmt.Println(fabSearch(arr, 188))
}

```

## 查找的其它需求

假設一個數列

```
[1,2,3,3,4,5,6,6,6,6,7,9,10]
```

需求:

1. 找到第一個等於3的
2. 找到最後一個等於3的
3. 找到第一個大於等於2的
4. 找到最後一個小於7的數據

```go
package main

import "fmt"

func binSearch(arr []int, data int) int {
	low := 0
	high := len(arr) - 1

	index := -1
	for low <= high {
		mid := (low + high) / 2
		if data < arr[mid] {
			high = mid
		} else if data > arr[mid] {
			low = mid
		} else {
			index = mid
			fmt.Println("index:", index)
			return index
		}
	}
	return index
}

//找到第一個為某數的
func binSearchFindFirst(arr []int, data int) int {
	low := 0
	high := len(arr) - 1

	index := -1
	for low <= high {
		mid := (low + high) / 2
		if data < arr[mid] {
			high = mid
		} else if data > arr[mid] {
			low = mid
		} else {
			if mid == 0 || arr[mid-1] != data {
				index = mid
				break
			} else {
				high--
			}
		}
	}
	return index
}

//找最後一個
func binSearchFindLast(arr []int, data int) int {
	low := 0
	high := len(arr) - 1
	index := -1
	for low <= high {
		mid := (low + high) / 2
		if data < arr[mid] {
			high = mid
		} else if data > arr[mid] {
			low = mid
		} else {
			if mid == len(arr)-1 || arr[mid+1] != data {
				index = mid
				break
			} else {
				low++
			}
		}
	}
	return index
}

//找到第一個大於等於某數的位置
func binSearchFindGreat(arr []int, data int) int {
	low := 0
	high := len(arr) - 1

	index := -1
	for low <= high {
		mid := (low + high) / 2
		if data < arr[mid] {
			high = mid
		} else if data > arr[mid] {
			low = mid
		} else {
			if mid == len(arr)-1 {
				index = mid
				break
			} else if arr[mid+1] > data {
				index = mid + 1
				break
			} else {
				low++
			}
		}
	}
	return index
}
func main() {
	arr := []int{1, 2, 2, 3, 3, 4, 4, 5, 5, 5, 5, 6, 6, 6, 7, 8, 9, 9, 9}
	var val int
	fmt.Println("輸入要搜尋的數:")
	fmt.Scan(&val)
	fmt.Printf("第一個為%d的位置為%d\n", val, binSearchFindFirst(arr, val))
	fmt.Printf("最末個為%d的位置為%d\n", val, binSearchFindLast(arr, val))
	fmt.Printf("第一個大於%d的位置為%d\n", val, binSearchFindGreat(arr, val))

}

```

#### 尋找第N大的值