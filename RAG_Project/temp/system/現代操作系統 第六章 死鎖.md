# 第六章 死鎖

在作業系統中有很多獨占性的資源，在任一時刻它們都只能被一個進程使用。常見的有印表機、磁帶以及系統內部表中的表項。

在很多應用中，需要一個進程排他性地訪問若干種資源而不是一種。例如有兩個進程準備分別將掃描的文檔記錄到藍光光盤上。進程A請求使用掃描儀，並被授權使用，但進程B首先請求藍光光盤刻錄機，也被授權使用。現在，A 請求使用藍光光盤刻錄機，而且去請求掃描儀。這時，兩個進程都被阻塞，並且一直處於這樣的狀態，就是**死鎖（dead lock）**

## 6.1 資源

在進程對設備、文件等取得了排他性訪問權時，有可能會出現死鎖。

這類需要排他性使用的對象稱為**資源**

資源是一種隨著時間的推移，必須能獲得、使用、釋放的任何東西。

### 6.1.1 可搶占資源和不可搶占資源

**可搶占資源（preemptable resource）**：可從擁有它的進程中搶占而不會產生任何副作用，例如，存儲器、記憶體。

**不可搶占資源（nonpreemtable resource）**：在不引起相關的計算失敗的情況下，無法把它從占有它的進程處搶占過來。如果一個進程已開始燒錄，突然將藍光光盤燒錄機分配給另一個進程，那麼將畫壞光盤。在任何時刻藍光光盤燒錄機都是不可搶占的。

某個資源是否可搶占取決於上下文環境。

死鎖與不可搶占資源有關，有關可搶占資源的潛在死鎖通常可以通過在進程之間重新分配資源而化解。

使用一個資源所需要的事件順序可以用抽象的形

## 6.2 死鎖簡介

死鎖定義如下：如果一個進程集合中的每個進程都在等待只能由該進程集合中的其他進程才能引發的事件，那麼，該進程集合就是死鎖。

由於所有的進程都在等待，所以沒有一個進程能引發可以喚醒該進程集合中的其他進程的事件，這樣，所有的進程都只好無限等待下去。

在大多數情況下，每個進程所等待的事件是釋放進程中其他進程所占有的資源。所以，死鎖進程集合中的每個進程都在等待另一個死鎖的進程已經占有的資源。

進程的數量以及占有或者請求的資源數量和種類都是無關的，且無論資源是何種類型（軟體或硬體）都會發生，就稱為**資源死鎖**

### 6.2.1 資源死鎖的條件

1. 互斥條件：每個資源要麼已經分配給了一個進程，要麼就是可用的。
2. 占有和等待條件：已經得到了某個資源的進程可以再請求新的資源。
3. 不可搶占條件：已經分配給一個進程的資源不能強制性地被搶占，它只能被占有它的進程顯式地釋放。
4. 環路等待條件：死鎖發生時，系統中一定有由兩個或兩個以上的進程組成的一條環路，該環路中的每個進程都在等待著下一個進程所占有的資源

死鎖發生時，此四個條件一定是同時滿足。

死鎖策略：

* 資源是否可同時分配給不同的進程？
* 一個進程能否在占有一個資源的同時請求另一個資源？
* 資源起否被搶占？
* 循環等待環路是否存在？

### 6.2.2 死鎖建模

![image-20200823110230896](/home/jackyfeng/GoogleDrive/電子書/學習筆記/os-graph6-3.jpg)

​                                                                                     圖6-3 

圓形表示進程

方形表示資源

從資源節點到進程節點的有向邊代表該資澦已被請求、授權並被進程占用。

從進程節點到資源節點的有向邊表示當前進程正在請求該資源，並且該進程已被阻塞，處於等待該資源的狀態。

圖中環形代表進入了死鎖狀態：進程C等待著資源T，資源T被進程D占用著，進程D又等待著由進程C占用的資源U。

## 6.3 鴕鳥算法

最簡單的解法就是假裝問題不存在

## 6.4 死鎖檢測和死鎖恢復

系統並不試圖阻止死鎖的產生，而是允許死鎖發生，當檢測到死鎖發生後，採取措施進行恢復。

### 6.4.1 每種類型一個資源的死鎖檢測

最簡單的模型。

即不存在兩個相同類型的設備的情況。

可以對這樣的系統構造一張資源分配圖，如圖6-5所示。

如果資源圖中存在一個或一個以上的環，那麼死鎖就存在。在此環中的任何一個進程都是死鎖進程。如果沒有這樣的環，系統就沒有發生死鎖。

討論更複雜的情況，假設一個系統包括A到G共7個進程，R到W共6種資源。資源的占有情況和進程對資源的請求情況如下：

1）A進程持有R資源，但需要T資源。

2）B進程不持有任何資源，但需要T資源。

3）C進程不持有任何資源，但需要S資源。

4）D進程持有U資源，且需要V資源。

5）E進程持有T資源，且需要V資源。

6）F進程持有W資源，且需要S資源。

7）G進程持有V資源，且需要U資源。

![image-20200823110230896](/home/jackyfeng/GoogleDrive/電子書/學習筆記/os-graph6-5.jpg)

檢測環路的算法：

這種圖對有向圖進行檢測，並在發現圖中有環路存在或確定無環路時結束。

對一個數據結構的集合L運行環路檢查的算法：

1. 對圖中的每一個節點N，將N作為起始點執行下面5個步驟。
2. 將L初始化為空表，並清除所有的有向邊標記。
3. 將當前節點添加到L的尾部，並檢測該節點是否在L中已出現過兩次。如果是，那麼該圖包含了一個環（已列在L中），算法結束。
4. 從給定的節點開始，檢測是否存在沒有標記的從該節點出發的弧（有向邊）。如果存在的話，做第5步；如果不存在，跳到第6步。
5. 隨機選取一條沒有標記的從該節點出發的弧（有向邊），標記它。然後順著這條弧找到新的當前節點，返回到第3步。
6. 如果這一節點是起始節點，那麼表明該圖不存在任何環，算法結束。否則意味著我們走進了死胡同，所以需要移走該節點，返回到前一個節點，即當前節點前面的一個節點，並將它作為新的當前節點，同時轉到第3步。

### 6.4.2 每種類型多個資源的死鎖檢測

### 6.4.3 從死鎖中恢復

#### 利用搶占恢復

強迫將某個資源從它的當前所有者那裡轉移給另一個進程。

取決於哪一個進程擁有比較容易收回的資源。

#### 利用回滾恢復

如果系統設計人員了解到死鎖有可能發生，他們就可以周期性地對進程進行**檢查點檢查**。這是一種將進程的狀態寫入一個文件以備以後重啟。該檢查點中不僅包括存儲映像，還包括了資源狀態，即哪些資源分配給了該進程。為了使這一過程更有效，新的檢查點不應覆蓋原有的文件，而應寫到新文件中。這樣，當進程執行時，將會有一系列的檢查點文件被累積起來。

一旦檢測到死鎖，就很容易發現需要哪些資源。為了進行恢復，要從一個較早的檢查點上開始，這樣擁有需要資源的進程會回滾到一個時間點，在此時間點之前該進程獲得了一些其他的資源。在該檢查點後所做的所有工作都丟失。實際上，是將該進程復位到一個更早的狀態，那時它還沒有取得所需的資源，接著就把這個資源分配給一個死鎖進程。如果復位後的進程試圖重新獲得對該資源的控制，它就必須一直等到該資源可用時為止。

#### 通過殺死進程恢復

最直接也是最簡單的方法就是殺死一個或若干個進程。如果運氣不錯的話，其他進程將可以繼續。如果這樣做行不通的話，就需要繼續殺死進程直到打破死鎖環。

有可能的話，最好殺死可以從頭開始重新運行而且不會帶來副作用的進程。比如，編譯進程可以被重複運行，由於它只需讀入一個源文件和產生一個目標文件。如果將它中途殺死，它的第一次運行不會影響到第二次運行。