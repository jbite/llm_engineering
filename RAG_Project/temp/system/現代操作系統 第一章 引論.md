一個與微內核思想的略微變體是將進程劃分為兩類: 伺服器，每個伺服器提供某種服務;客戶端，使用這些服務。這個模式就是所謂的客戶機-伺服器模式。通常，在系統最底層豆微內核，但並不是必須這樣的。這個模式的本質是存在客戶端進程和伺服器進程。

一般地，在客戶端和伺服器之間的通信是消息傳遞。為了獲得一個服務，客戶端進程構造一段消息，說明所需要的服務，並將其發給合適的伺服器。該服務完成工作，發送回應。和果客戶端和伺服器運行在同一個機器上，則有可能進行某種優化，但是從念上看，在這裡討論的是消息傳遞。

這個思想的一個顯然的、普遍方式是，客戶端和伺服器運行在不同的計算機上，它們通過局域或廣域網連接，如圖1-27所示。由是客戶端通過發送消息與伺服器通信，客戶端並不需要知道這些消息是在它們的本地機器上處理，還是通過網路被送到遠程機器垂處理。對於客戶端而言，這兩種情形是一樣的: 都是發送請求並得到回應。所以，客戶機-伺服器模式是一種可以應用在單機或者網路機器上的抽象。

越來越多的系統，包括用戶家裡的pc機，都成為了客戶端，而在某地運行的大型機器則成為伺服器。事實上，許多web就是以這個方式運行的。一台Pc機向某個伺服器請求一個Web頁面，而後，該Web頁面回送。這就長網路中客戶機-伺服器的典型應用方式。



虛擬機

os/360 的最早版本是純粹的批處理系統。然而，有許多360用戶希望能夠在終端上交互工作，于是在IBM公司的一些研究小組決定為它編寫一個分時系統。在後來推出了正式的IBM分時系統，TSS/360。但是它非常龐大，運行緩慢，于是在花費了約五千萬美元的研制費用後，該系統最後被棄之不用。但是在麻省劍橋的一個IBM研究中心開發了另一個完全的系統，這個系統被IBM最終作為產品。它的直接後續，稱為z/vm，目前在IBM的現的型機上廣泛使用,ZSERIES則在大型公司的數據中心中廣泛應用，例如，作為e-commerce伺服器，它們每秒可以處理成百上千個事務滿並使用達數百萬g字節的數據庫

這個系統最初被命名為cp/cms 後來改名為vm/370它是源以如下一種機敏的觀察。分時系統應該提供這些功能: 1 多道程序，2 一個比裸機更方便的、有擴展界面的計算機。vm/370存在的目的是將二者徹底地隔離開來。

這個系統的核心稱為虛擬機監控程序，它在裸機上運行並且具個了多道程序功能。該系統向上層提供了若干台虛擬機，如1-28所示。它不同于其他操作系統的地方是: 這些虛擬機不是那種具有文件等優良特徵的擴展計算機。與之相反



# 第一章

## 什麼是操作系統

操作系統是一種運行在內核態的軟體

### 1.1.1 作為擴展機器的操作系統

程序員需要的是一種簡單的、高度抽象的處理。抽象是管理複雜性的一個關鍵。好的抽象可以把一個幾手不可能管理的任務劃分為兩個可管理的部分。其第一部分是有關抽象的定義和實現，第二部分是隨時用這些抽象解決問題。

### 1.1.2 作為資源管理者的操作系統

按照功一種自底向上的觀點，操作系統則用來管理一個複雜系統的各個部分。操作系統的任務是在相互競爭的程序之間有氫地控制對處理器; 存儲器以及其他i/O設備的分配

現代操作系統允許同時運行多道程序。操作系統可以把潛在的混亂有序化

資源管理包括用以下兩種不同方式實現多路復用資源: 在時間上和在空間上復用

## 操作系統的歷史

### 1.2.1第一代(1945-1955)真空管和穿孔卡片

### 1.2.2 第二代(1955- 1965)晶體管和批處理系統

批處理就是: 在輸入室收集全部的作業，然後用一台相對便宜的計算機，如ibm 1401計算機，將它們讀到磁帶上。ibm 1401計算機適用於讀卡片; 複制磁帶和輸出打印，但不適用於數值運算。另外用較昂貴的計算機，如ibm 7094來完成真正的計算

### 1.2.3第三代(1965~1980)集成電路芯片和多道程序設計

system360被設計用來同時解決科學計算及商用打印服務 使用的是兼容的思想 

多道程序設計: 將記憶體分成幾個部分，每一部分存放不同的作業，如圖1- 5所示。當一個作業等待i/o操作完成時滿另一個作業可以使用cpu。如果記憶體中可以同時存放足夠多的作業，則cpu利用率可以接近100%。在記憶體中同時駐留多個作業需要特殊的硬體來對其進行保護，以避免作上的信息被竊取或受到攻擊。

SPOOLing:simultaneous peripheral operation on line 任何時刻當一個作業運行束時，操作系統就能將一個新作業從磁盤讀出，裝進空出來的內存區域運行

分時系統: 是多道程序的變體，每個用戶都有一個聯機終端。當多個用戶同時使用時，某些用戶在等待時，則cpu會分配給需要運算的用戶輪流執行。由於調試程序的用戶常常只發出簡短的命令，而很少有長的費時命令，所以計算機能夠為許多用戶提供快速的交互式服務，同時在cpu空閒時這可能在後台運久一個的作業

### 1.2.4第四代(1980年至今):個人計算機

因為LSI(大規模集成電路)的發展，在每平方公分的矽片上可以集數千個晶體管，讓個人計算機時代到來

20世紀80年代中期的有趣發展是，那些運行`網路操作系統`和`分布式操作系統`的個人計算機網路的增長。在網路操作系統中，用戶知道多台計算機的存在，用戶能夠登錄到一台遠地機器上並將文件從一台機器複制到另一台機器，每台機算機都運行自己本地的操作系統，並有自己的本地用戶(或多個用戶)

網路作系統與單處理器的操厏系統沒有本質區另。它們需要一個網路接口控制器以及一些低層軟體來驅動它，同時還需要一些程序來進行遠程登錄和遠程文件訪問。

## 1.3 計算機硬體介紹

### 1.3.1 處理器

在每個CPU基本周期中，首先從內存中取出指令，解碼以確定其類型和操作數，接著執行之，然後取指、解碼並執行下一條指令

指令集 

CPU內部都有一些用保存關鍵變量和臨時數據的寄存器

程序計數器，它保存了將要取出的下一條指令的內存地址。在指令取出之後，程序計數器就被更新以便指向後繼的指令。

程序狀態字(program status word, PSW)寄存器。這個寄存器包含了條件碼位(由比較指令設置)、CPU優先級、模式，以及各種其他控制位。



#### 流水線(pipeline): 

一個CPU可以有分開的取指單元、解碼單元和執行單元，於是當它執行指令N時，它還可以對指令n+1解碼，並且對讀取指令N+2。一旦一條指令被取進流水線中，它就必須被執行完畢，即便前一條取出的指令是條件轉移，它也必須被執行完畢

#### 超標量CPU

比流水線更先進的設計是一種超標量cpu，如圖1-7b所示。在這種設計中，有多個執行單元，例如，一個cpu用於整數算術運算，一個cpu用於浮點算術運算。兩個或更多的指令毎同時取出、解碼並裝入一個保持緩沖區中，直至它們執行完畢。只要有一個執行單元空閒，就檢查保持緩沖區中是否還有可處理的指令，如果有，就把指令從緩沖區中移出並執行之。這種設計存在一種隱含的作用，即程序的指令經常不按順序執行。在多數情況下，硬件負責保證這種運算的結果與順序執行指令時的結果相同，但是，仍然有部分令人煩惱的複雜情形被強加給操作系統處理，我們在後面會討論這種情況。

![image-20200718104826862](D:\google\電子書\學習筆記\image-20200718104826862.png)

除了用在嵌入式系統中的非常簡單的cpu之外，多數cpu都有兩種模式，即前面已經提及的內核態和用戶態。通常，在psw中有一個二進制位控制這兩種模式。當在內核態運行時，cpu可以執行指令集中的每一個條令冫且使用硬體的每種功能。操作系統內核態下運行，從而可以訪問整個硬體。

相反，用戶程序在用戶態下運行，僅允許執行整個指令集的一個子集和訪問所有功能的一個子集。一般而言，在用戶態中有關i/o和內存保護的所有指令是禁止的。當然，將psw中的模式位設置成內核態也是禁止的。

為了從操作系統中獲得服務，用戶程序必須使用`系統調用`系統調陷入內核並調用操作系統。trap指令把用戶態切換成內核態，並啟用操作系統。當有關工作完成之後，在系統調用後面的指令把控制權返回給用戶程序。

#### 多線程(multithreading)或超線程(hyperthreading)

多線程允許CPU保持兩個不同的線程狀態，然後在納秒級的時間尺度來回切換。一個時刻只能有一個進程在運行，但是線程的切換時間則減少到納秒數量級。

### 1.3.2 存儲器

計算機中的第二種主要部件都是存儲器。存儲器應該極為快速，充分大，並且非常便且。

存儲器採用一種分層次的處理的結構。頂層的存儲器速度較高，容量較小，成本較高。

* 寄存器: 最快速的存儲器，材料與cpu相同，訪問時間1ns。存儲容量是32位cpu中為32x32位，64位cpu中為64x64位。都小於1kb
* 高速緩存: 主存分割為高速緩存行，大小為64個字節，地址0至63 對應高速緩存行0，地址64至127對應高速緩存行1，以此類推。最常幅十高速緩存行放置在cpu內部或非常接近cpu的高速緩存中。高速緩存可能分為兩級或三級高速緩存，每一級高速緩存比前一級慢且容量更大

緩存需要考慮的問題

1. 何時把一個新的內容放入緩存
2. 把新內容放存緩存的哪一行上
3. 在需要時，應該把哪個內容從緩存中移走
4. 應該把新移走的內容放在某個較大存儲器的何處 

* 主存通常稱為隨機訪問存儲器(random access memory, RAM)

### 1.3.5 I/O設備

包括設備控制器和設備本身。控制器是插在電路板上，從操作系統接收命令，例如，從設備讀數據，並完成數據的處理

設備寄存器: 

	1. 映射到操作系統的地址空間，可以像普通存儲字一樣讀出和寫入。八需要專門的I/O指令，但是占用了一些地址空間
 	2. 寄存器被放入一個專目的i/o端口空間中，每個寄存器都有一個端口地址。內核態可使用的專門in和out指令，供設備驅動程序讀寫這些寄存器用。不占用額外的地址空間

輸入輸出的方法:

* 用戶程序發出一個系統調用，內核將其翻譯成一個對應設備驅動程序的過程調用。然後設備驅動程序啟動i/o並在一個連續不斷的循環中檢查該設備，看該設備是否完成了工作(一般有一些二進制位用來指示設備仍在忙碌中)。當i/o結束後，設備驅動程序把數據送到指的地方(如果有需要)，並返回。然後操作系統將控制返回給調用者。這種方式稱為忙等待。
* 設備驅動程序啟動設備並且讓該設備在操作完成時發出一個中斷。設備驅動程序在這個時刻返回。操作系統接著在需要時阻塞調用者並安排其他工作進行。當設備驅動程序檢測到該設備的操作完畢時，它發出一個中斷通知操作完成
* i/o使用一種特殊的直接存儲器訪問(Dirext Memory Access, DMA)芯片，它可以控制在記憶體如某些控制器之間的位流，而無須持續的cpu干預。cpu對DMA芯片進行設置，說明需要傳送的字節數、有關的設備和記憶體地址以及操作方向，接著啟動MDA。當DMA芯片完成時，它引發一個中斷，其處理方式如前所述。

中斷控制: 如圖1-11a，

* 第1步，設備驅動程序通過寫設備寄存器通知設備控制器做什麼。然後，設備控制器啟動該設備。
* 第2步，當設備控制器傳送完畢被告知的要進行寫操作的字節數量後，使用特定的總線發信號給中斷控制器芯片。
* 第3步，如果中控制器已經準備接收中斷(如果正忙於一個更高級的中斷，也可能不接收)，會在CPU芯片的一個管腳上聲明。
* 第4步，中斷控制器把該設備的編號放到總線上，這樣CPU可以讀總線，並且知道哪個設備剛剛完成了操作

![image-20200720100926254](D:\google\電子書\學習筆記\image-20200720100926254.png)

中斷處理過程:(如圖1-11B)

1. 取中斷，程序計器和PSW就被壓入當前堆棧中，CPU切換到用戶態。設備編號可以成為部分記憶體的一個引用，用尋找該設備中斷處理程序的地址，稱為中斷向量。
2. 中斷處理程序取走在棧中的程序計數器和PSW，並保存之，然後查詢設備的狀態。
3. 處理完成後，返回到先前運行的用戶程序中尚未執行的頭一條指令。

### 1.3.6總線

圖中的系統有8 個總線(高速緩存、局部、內存、PCI、SCSI、USB、IDE和ISA)，每個總線傳輸速度和功能都不同。操作系統必須了解所有總線的配置和管理。

* 高速緩存: CPU與2級緩存對話
* 局部: CPU與PCI橋芯片對話
* 內存: PCI橋芯片與存儲器對話
* PCI(Peripheral Component Interconnect):主要總線之一，可在66MHz頻率運行，可併行傳送8字節，數據速率為528MB/s
* SCSI(Small Computer System Interface): 是一種高速總線，用在高速硬碟、掃描器和其他需較的帶寬的設備上。可達320MB/s
* USB(Universal Serial Bus) 
* IDE
* ISA(Industry Standard Architecture): 主要總線之一,，以8.33MHz運行

![image-20200720103135750](D:\google\電子書\學習筆記\image-20200720103135750.png)

隨插即用(plug and play): 有不同級別的中斷請求和用於寄存器的固定地址，例如鍵盤的中斷級別是1，並使用0x60至0x64的i/o地址。隨插即用的工作是，系統自動地收集有關i/o設備的信息，集中賦予中斷級別和i/o地址，然後通知每塊卡所使用的數值。

### 1.3.7 啟動計算機

1. 開機

2. BIOS開始運行。

3. BIOS檢查所安裝的RAM數量，鍵盤和其他基本設備是否已安裝並正常響應。

4. BIOS掃描ISA和PCI總線並找出連在上面的所有設備，並且紀錄下來

5. BIOS讀取CMOS存儲器中的設備清單決定啟動設備。

6. 啟動設備上的第一個扇區被讀入記憶體並執行。

7. 檢查分區表，以確定哪些分區表是活動的。然後，從該分區表讀入第二個啟動裝戴模塊並讀入操作系統，並啟動。

8. 操作系統詢問BIOS，獲得配置信息。將全部的設備驅動程式調入內核。

9. 初始化有關表格，創逼需要的任何背景進程，並在每個終端上啟動登錄程式或GUI。

   

   

## 1.4 操作系統大觀園

* 大型機操作系統
* 伺服器操作系統
* 多處理器操作系統
* 個人計算機操作系統
* 掌上計算機操作系統
* 嵌入式操作系統
* 傳感器節點操作系統
* 實時操作系統
* 智能卡操作系統

## 1.5 操作系統概念

### 1.5.1 進程

在所有操作系統中，一個重要的概念是`進程`。進程本質上是正在執行的一個程式。與每個進程相關的是進程的地址空間，這是從某個最小值的存儲位置(通常是零)到某個最大值存儲位置的列表。在這個地址空間中，進程可以進行讀寫。該地址空間中存放有可執行程序、程序的數據以及程序的堆棧。與

#### 資源集: 

包括寄存器(含有程序計數器和堆棧指針)、打開文件的清單、突出的報警、有關進程清單，以及運行該程序所需要的所有其他信息。

進程基本上是容納運行一個程序所需要所有信息的容器。

​	進程的概念將在第2 章詳細討論，不過，對進程建立一種直觀感覺的最便利是分析一個分時系統。用戶會啟動一個視頻編輯程式，並指令它按照某個格式轉換一小時的視頻(有時會花費數小時)，然後離開去WEB上沖浪。同時，一個被周期性喚醒，用來檢查進來的E-MAIL的後台進程會開始運行。這樣，我們就有了三個活動進程:視頻編輯器、WEB瀏覽器以及EMAIL接收器。操作系統周期性地掛起一個進程然後啟動運行另一個進程。例如，在過去的一秒鐘內，第一個進程已使用完分配給它的時間片。

#### 進程表

保存一個進程暫時被掛起後的狀態。在随後的某個時刻裡，該進程再次啟動時的狀態必須與先前暫停時完全相同滿這就意味著在掛起進程的所有信息都要透過進程表保存下來。

進程表是一個數組結構。

與進程管理有關的最關鍵的是`進程創鍵`及`進程終止`的系統調用

一個進程可以創建一個或多個進程，稱為子進程，這些子進程又可以創建子進程，就得到一個進程樹。

### 1.5.2 地址空間

主存用來保存正在執行的程式。操作系統透過保護機制在記憶體中避免因為運行多道程序而造成的干擾。

### 1.5.3 文件

大多數操作系統透過目錄的概念來支持文件系統，並且通過這個概念將文件分組。

讀寫文件之前，首先要打開文件，檢查其訪問權限。若權限許可，系統將返回一個小整數，稱作文件描述符(file descriptor)，供後續操作使用。若禁止訪問，系統則返回一個錯誤碼。

在unix中，在另一個重要的概念是特殊文件。特殊文件保存在/dev目錄中

* 塊特殊文件(block special file): 指向那些由可隨機存取的塊組成的設備，如磁碟。
* 字符特殊文件(character special file): 印表機、調制解調器和其他接收或輸出字符流的設備。

管道(pipeline): 是一種虛文件，它可連接兩個進程。如果希望兩個進程通過管道對話，必須提前設置該管道。當進程A想對進程B發送數據時，宅把數據寫到管道上，彷彿管道就是一個輸入文件一樣。

### 1.5.4 輸入/輸出

輸入: 鍵盤

輸出: 螢幕、印表機

### 1.5.5 保護

用戶經常需要對其信息進行保護，包含了電子郵件、商業計劃、退稅等內容。

UNIX操作系統通過對每個文件賦予一個9位的二進制保護代碼，對UNIX中的文件實現保護。

該保護代碼有三個3位字段，

* 一個用於所有者
* 一個用於所有者同組(用戶被系統管理員劃分成組)中的其他成員
* 一個用於其他人

每個字段中有一位用於讀訪問，一位用於寫訪問，一位用於執行訪問

這就是知名的rwx位。

## 系統調用

操作系統的兩個功能

* 為用戶程序提供抽象
* 管理計算機資源

很多操作系統通過提供過程庫使大多數語言可以使用系統調用

#### 系統調用的過程

任何單CPU計算機一次只能執行一條指令。如果一個進程正在用戶態中運行一個用戶指令，並且需要一個系統服務，比如從一個文件讀數據，那麼它就必須執行一個陷阱或系統調用指令，將控制轉移到操作系統。操作系統接著通過參數檢查，找出所需要的調用進程。然後，它執行系統調用，並把控制權返回給系統調用後面跟隨著的指令。

#### READ系統調用

有三個參數: 1: 指定文件，2: 指向緩沖區，3: 要讀出的字節數

由C語言進行的調用如下:

​	count = read(fd, buffer, nbytes);

步驟:

1~3 : 把參數壓入堆棧中

4: 調用read

5: 把系統調用的編號放在操作系統所期的地方，如寄存器

6: 執行一個TRAP指令，將用戶態切換到內核態，並在內核中的一個固定地址開始執行。TRAP指令後面跟隨一個來自遠地位置的指令，以及供以後使用的一個保存在棧中的返回地址。

7: 內核代碼開始檢查系統調用編號，然後發出正確的系統調用處理命令，這通常是通一張由系統調用編號所引用的，指向系統調用處理器的指針表來完成

8: 系統調用句柄運行

9: 工作完成後，控制權可能返回給跟隨在TRAP指令後面的用戶空間庫

系統調用可能堵塞調用者，避免它繼續執行。例如試圖讀鍵盤，但是並沒有任何鍵入，那麼調用者就必須被阻塞。操作系統會查看是否有其他可以運行的進程，稍後，當需要的輸入出現時，進程會提醒系統注意，接著進行之後的步驟。

10: 返回用戶程序

11: 用戶程序清除堆棧

![image-20200720141255046](D:\google\電子書\學習筆記\image-20200720141255046.png)

### 常見的系統調用

#### 進程管理

| 調用                                  | 說明                     |
| ------------------------------------- | ------------------------ |
| pid = fork()                          | 創建與父進程相同的子進程 |
| pid = waitpid(pid, &statloc, options) | 等待一個子進程終止       |
| s = execve(name, argv, environp)      | 替換一個進程的核心映像   |
| exit(status)                          | 中正進程執行並返回狀態   |

#### 文件管理

| 調用                                 | 說明                         |
| ------------------------------------ | ---------------------------- |
| fd = open(file, how, ...)            | 打開一個文件供讀、寫或兩者   |
| s = close(fd)                        | 關閉一個打開的文件           |
| n = read(fd, buffer, nbytes)         | 把數據從一個文件讀到緩沖區中 |
| n = write(fd, budder, nbytes)        | 把數據從緩沖區寫到一個文件中 |
| position = lseek(fb, offset, whence) | 移動文件指針                 |
| s = stat(name,&buf)                  | 取得文件的狀態信息           |

#### 目錄和文件系理系統

| 調用                           | 說明                               |
| ------------------------------ | ---------------------------------- |
| s = mkdir(name, mode)          | 創建一個新目錄                     |
| s = rmdir(name)                | 刪去一個空目錄                     |
| s = link(name1, name2)         | 創建一個新目錄項name2, 並指向name1 |
| s = unlink(name)               | 刪去一個目錄項                     |
| s = mount(special, name, flag) | 安裝一個文件系統                   |
| s = umount(special)            | 卸載一個文件系統                   |

#### 雜項

| 調用                     | 說明                       |
| ------------------------ | -------------------------- |
| s = chdir(dirname)       | 改變工作目錄               |
| s = chmod(name, mode)    | 修改一個文件的保護位       |
| s = kill(pid, signal)    | 發送信號給一個進程         |
| seconds = time(&seconds) | 自1970年1月1日起的流逝時間 |

## 1.7 操作系統結構

### 1.7.1 單體系統

構造: 首先編譯所有單個的過程，或者編譯包含過程的文件，然後通過系統鏈結程序將他們鏈接成單一的目標文件。

基本結構

1. 需要一個主程序，用來處理服務過程請求
2. 需要一套服務過程，用來執行系統調用。
3. 需要一套實用過程，用來輔助服務過程。

每一個系統調用都通過一個服務過程為其工作並運行之。

![image-20200720163649063](D:\google\電子書\學習筆記\image-20200720163649063.png)

要有一組實用程序來完成一些服務過程需要用到的功能

除了在計算機初啟動時所裝載的核心操作系統外，許多操作系統支持可裝載的擴展，諸如i/o設備驅動和文件系統

### 1.7.2 層次系統

將圖1-24的系統進一步通用化，就變成一個層次式結構的操作系統，它的上層軟體都是在下一層軟體的基礎之上構建的。

0層: 處理器分配和多道程序設計，當中斷發生或定時器到期時，由該層進行進程切換。在0層之上，系統由一些連續的進程所組成，編寫這些進程時不用再考慮在單處理器上多進程運行的細節。

1層: 存儲器和磁鼓管理，負責進程的主存空間，當記憶體快用完時則在一個512K字的磁鼓上保留進程的一部分。進程不用考慮它是在磁鼓上還是在記憶體中運行。第一層軟體保證一旦需要訪問某一頁面時，該頁面必定已在記憶體中

2層: 操作員-進程通信，可以想成每個進程都有自己的操作員控制台。

3層: 輸入/輸出管理，和I/O設備有關的信息流緩沖區。I/O都已經抽象好了。

4層: 用戶程序，用戶程序不用考慮進程、記憶體、控制台或I/O設備管理等細節。

5層: 操作員

### 1.7.3 微內核

每千行代碼中會有10個錯誤

微內核設計是為了實現高可靠性，將操作系統劃分成小的、良好定義的模塊，只有`微內核`這個模塊運行在內核態上，其餘模塊則作為普通用戶進程運行。所以，這些模塊雖然會使這些模塊崩潰，但不會使整個系統死機。

再生伺服器，其任務是檢查其他伺服器和驅動器的功能是否正確。一旦檢查出一個錯誤，它自動取代之，無須任何干預

### 1.7.4 客戶機-伺服器系統

是一種微內核的變體，將進程分為兩類

* 伺服器: 提供某種服務
* 客戶端: 使用這些服務

客戶端和伺服器之間的通信是消息傳遞。客戶端會構造一段消息，說明需要的服務，並將其發給合適的伺服器來獲得一個服務。

伺服器完成工作，發送回應。

普遍上，它們透過區域網路或廣域網連接。客戶端不需要知道請求是在本地或是在遠端處理。

### 1.7.5 虛擬機

### 1.7.6 exokernels(外核)





## 習題

1. 什麼是多道程序設計

   A: 同時將運行多個進程，這些進程由操作系統控制其啟動、中斷、阻塞

2. 什麼是SPOOLing?讀者是否認為將來的高級個人計算機會把SPOOLing作為標準功能

3. 在早期計算機中，每個字節的讀寫直接由cpu處理。對於多道程序而言這種組織方式有什麼含義

4. 系列計算機的思想在20世紀60年代由ibm引入進system/360的型機。現在這種思想已經消亡了這是繼續活躍者?

5. 緩慢采用gui的一個原因是支持它的硬體的成本。為了支持25行80列字簽的單色文本屏幕應該需要多少視頻ram?在1980年($5/kb)這些eam的成本是多少?現在它的成本是多少?

6. 在建立一個操系統時有幾個設計目的，例如資源利用;、及時性、健壯性等。請列舉兩個可能互相矛盾的設計目的。

7. 下面的哪一條指令只能在內核態中使用?

    a. 禁止所有的中斷

   b. 讀日期-時間時鐘

   c. 設置日期-時間時鐘

   d. 改變存儲器映像

8. 考慮一個有兩個cpu的系統，並且每一個cpu有兩個線程(超線程)。假設有三個程序p0，p1，p2，分別以運行時間5ms、10ms、20ms開始。運久這些程序需要多少時間?假設這三個程序都是100%限於cpu，在運行時無阻塞，並且一旦設定就不改變cpu
9. 一台計算機有一個四級流水線，每一級都花費相同的時間執行其工作，即1ns。這台機器每秒可執行多條指令。
10. 假設一個計算機系統有高速緩存、內存以及磁盤，操作系統用虛擬內存。讀取緩存中的一個詞需要2ns，ram需要10ns，磁盤需要10ms。如果緩存的命中率是95%，內存的是(緩存失效時)99%，讀取一個詞的平均時間是多少?
11. 一位校對人員注意到在一部將要出版的操作系統教科書手稿中有一個多次的拼寫錯誤。這本書的致有700頁。每頁50行，一行80個字符。若把文稿用電子掃描，那麼，主副本進入圖1-9中的每個存儲系統的層次要花費多少時間?對於內存儲方式，考慮所給定的存取時間是每次一個符，對於磁盤設備，假定存取時間是每次一個1024字符的盤塊，而對於磁帶，假設給定開始時間後的存取時間和磁盤存取時間相同。
12. 在用戶程序進行一個系統調用，以讀寫磁盤文件時，該程序提供指示說明了所需要的文件，一個指向數據緩沖區的指針以及計數。然後，控制權轉給操作系統，它調用相關的驅動程式。假設驅動程式啟動磁盤並且直到中斷發生才終止，在從磁盤讀的情況下，很明顯，調用者會被阻塞(因為文件中沒有數據)。在向磁盤寫時會發生什麼情況?需要把調用者阻塞一直等到磁盤傳送完成為止嗎?



