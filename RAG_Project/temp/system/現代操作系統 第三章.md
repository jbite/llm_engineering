# 第三章 存儲管理

## 3.1 無存儲器抽象

最簡單的存儲器抽象就是根本沒有抽象。

當一個程序執行如下指令：

​	MOV REGISTER1, 1000

電腦會將位置為1000的物理記憶體中的內容移到REGISTER1中。因此，那時呈現給程式人員的存儲器模型就是簡單的物理記憶體：從0到某個上限的地址集合，每一個地址對應一個可容納一定數目二進制位的存儲單元，通常是8個。

這種情況下，不能同時運作兩個程式。後進入的程式會將前一個程式在記憶體中的值給刪除。，因此兩個程式會立刻崩潰。

#### 記憶體的組織方法

一、操作系統位於RAM(random access memory)的底部，用戶程式在上面

二、操作系統位於記憶體頂端的ROM，用戶程式位於ROM下方

三、設備驅動程式位於ROM，稱為BIOS。操作系統一樣在RAM中，上方就是用戶程式。

用這些方式組織時，同一時刻就只能有一個進程有運行。

在沒有記憶體抽象的系統中實現併行的一種方法是使用多線程編程。

#### 在不使用記憶抽象下運行多道程序

操作系統只需把當前記憶中所有內容保存到磁盤文件中，然後把下一個程序讀入到內存中再運行即可。

最早是使用記憶體鍵來定位指令。記憶體被分為2KB的塊，每個塊被分配一個4位的保護鍵，保護鍵存儲在CPU的特殊寄存器中。

需要讓所有程式運行在相對的記憶體空間中，才不會因為指令指向絕對空間而導致崩潰。

## 3.2 一種存儲器抽象：地址空間

把物理地址暴露給進程會帶來下面幾個嚴重問題：

一、用戶程序可以很容易的破壞操作系統，除非有特殊的硬體進行保護，如IBM 360的鎖鍵模式

二、想要同時運行多個程序是很困難的。

### 3.2.1 地址空間的概念

要讓多個程式在記憶中互不影響需要解決兩個問題：

一、保護：

二、重定位：

其中IBM 360就是用記憶體標記上一個保護鍵，並且比較進程的鍵和其訪問的每個記憶體字的保護鍵。IBM 360本身只解決了第一個問題。

一個更好的辦法是創造一個新的記憶體抽象：地址空間。就像進程的概念創造了一類抽象的CPU以運行程序一樣，地址空間為程序創造了一種抽象的記憶體。

地址空間是一個進程用於尋址記憶體的一套地址集合。每一個進程都有自己的地址空間，並且這個地址空間獨立於其他進程的地址空間。

地址空間就像不同國家有自己的電話號碼系統，並且使用國碼來區別。

也像是網址中的.com來區別不同種類的域名。

#### 基址寄存器與界限寄存器

這個解決方案使用`動態重定位`。他是簡單的把每個進程的地址空間映射到物理記憶體的不同部份。

這是兩個特殊的寄存器

基址寄存器：程式裝載時的起始物理地址。

界限寄存器：程式裝載時，裝載程式的長度

例如，第一個程式的基址為0、界限值為16384。

第二個程式的值分別為16384和32768

如果第三個16kb的程式被直接裝載在第二個程式的地址之上並且運行時，基址為32768、界限值為16384

![image-20200724202653884](D:\google\電子書\學習筆記\image-20200724202653884.png)

每次一個進程訪問記憶體，取一條指令，讀或寫一個數據字，CPU硬體會在把地址發送到記憶體總線前，自動把基址值加到發出的地址值上。同時，它檢查程式提供的地址是否等於或大於界限寄存器裡的值。如果訪問的地址超過了界限，會產生錯誤並中止訪問。

許要對基址寄存器和界限寄存器做一定的保護。

缺點：每次訪問記憶體都需要進行加法和比較運算。在沒有使用特殊電路的情況下，加法會做的很慢。

### 3.2.2 交換技術

理論上，物理記憶體夠的的話，可以保存所有進程，那麼之前提及的所有方案都是可行的。

但實際上，當一個操作系統啟動以後，會啟動40～60個，甚至更多的進程。

例如，windows通常會發出一系列命令，使得在此後的系統引導中會啟動一個僅僅用於查看該應用程序更新的進程。這樣一個進程會占據5～10MB的記憶體。諸如此類的程式還很多，因此啟動系統後，重要的應用程式就能占據50MB～200MB甚至更多的空間。

有兩種方式可以處理記憶體超載的通用方法：

一、交換：把一個進程完整調入記憶體，使該進程運行一段時間，然後把它存回磁盤。空閒進程主要存儲在磁盤上，所以當它們不運行時就不會占用記體

二、虛擬憶體：使程式在只有一部分被調入記憶體的情況下運行。

![image-20200724205847921](D:\google\電子書\學習筆記\image-20200724205847921.png)

這是一個記憶體隨著時間變化導入程式的過程。

程式在記憶體會順序加載。調出時會產生空閒區(hole，也稱為空洞)。

把所有進程盡可能地向下移動，有可能將這些小的空閒區合成一大塊，稱為記憶體緊縮(memory compaction)。這個操作並不常進行。

當進程創建或換入時應該分配多大的空間，是一個重要的問題。如果進程中的數據段可以增長，當進程數據增長時，就要考慮鄰接空間是否有空間、如果鄰接記憶體沒有空間了，就需要將進程交換到足夠大的空閒區。如果記憶體沒有空閒區了，磁盤上交換區也滿了，進程只能掛起。

也可以為可增長的進程，預留增長的空間。當進程交換到磁盤上時，只交換實際上有用到的部份。

### 3.2.3 空閒記憶體管理

管理記憶體時，有兩種方法跟踪記憶體使用情況

一、位圖：記憶體劃分為幾個字或幾千個字節的分配單元。每個分配單元對應於位圖中的一位，0表示空閒，1表示占用。分配單元越小，位圖越大。如果使用4個字節大小的分配單元，位圖則占用記憶體1/33的大小。

位圖在決定在記憶體中調入進程時，存儲管理器必須搜索位圖，在位圖中找出有k個連續-0的串，這是一個耗時的動作。

二、空閒鏈表：包含(H)表示空閒區，(P)表示進程的指示標志、起始位址、長度和指向下一結點的指針。

![image-20200724214858875](D:\google\電子書\學習筆記\image-20200724214858875.png)

## 3.3 虛擬記憶體

虛擬記憶體(virtual memory)的基本思想是：每個程式擁有自己的地址空間，這個空間被分割成多個塊，每一個塊作一頁或頁面(page)。每一頁有連續的地址範圍。這些頁被映射到物理記憶體，但並不是所有的頁都必須在記憶體才能運行程式。當程式引用到一部分在物理記憶體中的地址空間時，由硬體立刻執行必要的映射。當程式引用到一部分不在物理記憶體中的地址空間時，由操作系統負責將缺失的部分裝入物理記憶體並重新執行失敗的指令。

虛擬記憶體特別適合在多道程序設計系統中使用，許多程式的片段同時保存在記憶體中。當一個程式等待它的一部分讀入記憶體時，可以把CPU交給另一個進程使用。

### 3.3.1 分頁

在任何一台計算機上，程式引用了一組記憶體地址。

當程式執行指令

`MOV REG, 1000`

它把地址為1000的記憶體單元的內容複制到REG中。地址可通過索引、基址寄存器、段寄存器或其他方式產生。

由程式產生的這些地址稱為虛擬地址，它們構成了一個虛擬地址空間。在虛擬記憶體的情況下，虛擬地址直接送到記憶體管理單元(Memory Management Unit, MMU)上，MMU把虛擬地址映射為物理記憶體地址

![image-20200725101130034](D:\google\電子書\學習筆記\image-20200725101130034.png)

上圖是一台可以產生16位地址的計算機，地址範圍從0到64k，且這些地址是虛擬地址。而物理記憶體只有32kb，因此，磁盤上必須有一個可以大到64kb的程式核心映像的完整副本，以保證程式片段有需要時能被調入記憶體。

虛擬地址空間按照固定大小劃分為頁面。在物理記憶體中對應的單元稱為頁框。頁面和頁框的大小通常是一致的。

標記0K～4K的範圍表示該頁面的虛擬地址或物理地址是0～4095。4K～8K的範圍表示4096～8191。每一頁包含了4096個地址，起始於4096的整數倍位置，結束於4096倍數少1。

當程式試圖訪問地址0時，例如執行下面這條命令

`MOV REG, 0`

將虛擬地址送到MMU。

MMU看到虛擬地址落在頁面0(0～4095)，根據其映射結果，這一頁面對應的是頁框2(8192～12287)，因此MMU把地址變換為8192，並把地址8192送到總線上。記憶體對MMU一無所知，它只看到一個讀安地址8192的請求並執行它。MMU從而有效的把所有從0～4095的虛擬地址映射到了8192～12287的物理地址。

同樣的，指令`MOV REG,8192`轉換為`MOV REG, 24576`

圖3-9中，使用X來表示沒有被映射的頁，實際上，用一個`在/不在`位(present/absent bit)記錄頁面在記憶中的實際存在情況。

如果程式訪問了一個未映射的頁面，MMU會發現該頁面沒有被映射，於是使用`缺頁中斷`讓CPU陷入到操作系統。操作系統找到一個很少使用的頁框且把它的內容寫入磁盤(如果它不在磁盤上)。隨後把需要訪問的頁面讀到剛才回收的頁框中，修改映射關係，然後重新啟動引起陷阱的指令。

#### MMU的內部結構

例如虛擬地址8196，二進制0010000000000100，這個是一組虛擬地址。可分為4位的頁號和12位的偏移量。4位的頁號可以表示16個頁面，12位的偏移可以為一頁內的全部4096個字節編址。

​	可用頁號作為頁表的索引，以得出對應於該虛擬頁面的頁框號。如果"在/不在"位是0，則將引起一個操作系統陷阱。如果則位是1，則將在頁表中查到的頁框號複制到輸出寄存器的高3位中，再加上輸入虛擬地址中的低12位偏移量。

![image-20200725114757604](D:\google\電子書\學習筆記\image-20200725114757604.png)

### 3.3.2 頁表

頁表的目的是把虛擬頁面映射為頁框。

#### 頁表項的結構

一個頁表項是一個32位的結構。

![image-20200725150931358](D:\google\電子書\學習筆記\image-20200725150931358.png)

頁框號：對應的物理記憶體值

在/不在位：1表示有效，0表示該表項對應的虛擬頁面不在記憶體中。

保護位：指出一個頁允許什麼類型的訪問。可以用一位表示，0表讀/寫、1表只讀。也可使用三位，各位分別對應可讀、可寫、可執行。

修改位：如果一個頁面被標為修改過，也就是髒的數據，必須把它寫回磁盤。如果一個頁面是乾淨的，就簡單的丟棄就好，因為他在磁盤上的副本仍是有效的。

訪問位：如果該頁面被訪問時設置訪問位。這個值用來幫助操作系統在發生缺頁中斷時選擇要被淘汰的頁面。不被使用的頁面更適合被淘汰。

高速緩存位：可以禁止緩存以確保操厏系統是從I/O設備中取出數據而不是緩存的副本。

### 3.3.3 加速分頁過程

在分頁式系統中需要考慮以下問題：

一、虛擬地址到物理地址的映射必須非常快。

二、如果虛擬地址空間很大，頁表也會很大

最簡單的設計是使用「快速硬體寄存器」組成的單一頁表，每一個表項對應一個虛頁，虛頁號作為索引，如圖3-10。當啟動一個進程時，操作系統把保存在記憶體中的進程頁表的副本載入到寄存器中。在進程運行過程中，不必再為頁表而訪問記憶體。缺點是，頁表很大時，代價高昂。且上下文切換時，都需要重裝載整個頁表。

另一種方法，是整個頁表都放在記憶體中。所需要的僅僅是一個指向頁表起始位置的寄存器。這樣上下文切換時，進行虛擬地址到物理地址的映射只需要重新裝入一個寄存器。當然，這種方法速度很慢。

#### 1. 轉換檢測緩沖區(Translation Lookaside Buffer, TLB)

加速分頁，

使用分頁技術，在記憶體中取指令會降低速率，因為要訪問頁表而引起更多的記憶體訪問。

解決方案：對少量的頁面進行多次的訪問。使用一個小型的硬體，將虛擬地址直接映射到物理地址，而不必再訪問頁表，此設備稱為`轉換檢測緩沖區`，又稱為相聯存儲器(associate memory)。

通常在MMU中，包含少量的表項、此例中為8個，在實際中很少會超過64個。

每個表項紀錄了一個頁面的相關訊息，包括虛擬頁號、頁面的修改位、保護碼(讀/寫/執行權限)、對應的物理頁框，還有一個用來紀錄表項是否有效。

![image-20200725210437970](D:\google\電子書\學習筆記\image-20200725210437970.png)

將一個虛擬地址放入MMU中進行轉換時，硬體會先跟TLB中的表項比對，如果頁面號存在且不違反保護位的項目，就取出頁框號。

如果虛擬頁號不在TLB中時，就會進行正常的頁表查詢。接著淘汰一個TLB的表項，然後用新找到的頁表項代替它。當一個表項被清除出TLB時，將修改位複制到記憶中的頁表項，而除了訪問位，其他的值不變。當頁表項從頁表裝到TLB時，所有的值都來自記憶體。

#### 軟體TLB管理

許多機器上不是使用硬體的TLB，而是使用軟體的TLB。當發生TLB訪問失效，操作系統優先處理TLB失效而不是缺頁中斷。當然，這必須在幾個有限指令內完成，因為TLB失效比缺頁中斷更常發生。

如果TLB大到可以減少失效率時,TLB的軟體管理就會變得足夠有效。

增加TLB軟體管理的效能方法：

一、操作系統事先判斷哪些頁面會被用到，並預先加載到TLB中，以減少TLB失效時的處理開銷。例如伺服器可以收到客戶端消息後，在處理send的陷阱時，也預先裝入伺服器的代碼頁、數據頁以及堆棧頁，並在導致TLB失效前把它們裝載到TLB中。

軟失效：當一個頁面訪問有記憶體中而不在TLB中，此時需要更新TLB，不需要產生磁盤I/O。一般需要10～20個機器指令花費幾個ns完成。

硬失效：如果頁面不在TLB也不在記憶體中，則需要從磁盤中取得，花費大約幾個毫秒，處理時間是軟失效的百萬倍。

### 3.3.4 針對大記憶體的頁表

#### 1. 多級頁表

32位的虛擬地址分為10位的PT1域、10位的PT2域和12位的Offset(偏移量)，而頁面長度是4KB，共有2^20^個頁面。

![image-20200725221902173](D:\google\電子書\學習筆記\image-20200725221902173.png)

4GB的記憶體將會分成1024個4MB的塊組成的地址空間。

頂級頁表得到的表項中含有二級頁表的地址或頁框號。表項0指向程式正文的頁表，表項1指向數據的頁表，表項1023指向堆棧的頁表，其他的表項未用。把PT2域作為訪問選定的二級頁表的索引，以便找到該虛擬頁面的對應頁框號。

0000000001 0000000011 000000000100

#### 2. 倒排頁表(inverted page table)

在實際記憶體中，每一個頁框有一個表項。表項紀錄`(進程, 虛擬頁面)對`

缺點是當進程訪問虛擬頁面p時，必須搜索整個倒排頁表來查找某一個表項(n, p)。而且每一次記憶體訪問操作都要查找一次，不僅是在發生缺頁中斷時。

解決方案是使用TLB。如果TLB能夠紀錄頻繁使用的頁面，地址轉換就可能變得像通常的頁表一樣快。

但是，當發生TLB失效時，需要用軟體搜索整個倒排頁表。一個可行的實現該搜索的方法是建立一張HASH表，用虛擬地址來HASH。當前所有在記憶體中有相同HASH值的虛擬頁面被鏈接在一起，如圖3-14所示。如果HASH表中的槽數與機器中物理頁面數一樣多，那麼HASH表中的沖突鏈的平均長度將會是1個表項，這將會大大提高映射速度。一旦頁框號被找到，新的(虛擬頁號，物理頁框號)對就會被裝載到TLB中。

![image-20200726084806799](D:\google\電子書\學習筆記\image-20200726084806799.png)

## 3.4 頁面置換算法

頁面置換經常會在計算機設計中不同領域發生。

例如，高速緩存中會把最近使用過的32字節或64字節的存儲塊保存起來。而高速緩存的數據是從記憶體取得的。

又例如，WEB伺服器經常需要更新常訪問的WEB頁面，將其存放在存儲器的高速緩存中。

### 3.4.1 最優頁面置換算法

每個頁面都標計著首前被訪問前所要執行的指令數作為標記。最優算法規定應該替換標記最大的頁面。

這個算法最困難的，就是無法知道各個頁面下一次將在什麼時候被訪問。當然，通過首先在仿真程式上運行程式，跟蹤所有頁面的訪問情況，在第二次運行時利用第一次運行時收集的數據，是可以預測需要經過多少指令的。

主要是用來評估一個算法的優劣。

### 3.4.2 最近未使用頁面置換算法

每一個頁面都設置了兩個狀態位。當頁面被訪問時設置R位：當頁面被寫入時設置M位。

這個算法是這樣的：當啟動一個進程時，它的昕有頁面的兩個位都由操作系統設置成0，R位被定期地清零，以區別最近沒有被訪問的頁面和被訪問的頁面。

當發生缺頁中斷時，操作系統檢查所有的頁面並根據它們當前的R位和M位的值，把它們分為4類：

第0類：沒有被訪問，沒有被修改

第1類：沒有被訪問，已被修改

第2類：已被訪問，沒有被修改

第3類：已被訪目，已被修改

NRU算法隨機的在最近的一個Tik Tok(大約20ms)，淘汰一個沒有被訪問的已修改頁面。

### 3.4.3 先進先出頁面置換算法

FIFO

操作系統維護一個鏈表，最早進入的頁面在鏈表的最前面，因此可以很快的判斷誰先被移出。

### 3.4.4 第二次機會頁面置換算法

這是FIFO的改進，在頁面將被移出時，會先檢查它的R位，如果R位是0，代表這個頁面又老又沒被使用，會立刻被置換；如果是1，就將R位清0，並把該頁面放到鏈表的最後，修改它的裝入時間使它就像剛裝入的一樣，然後繼續搜索。

### 3.4.5 時鐘頁面置換算法

使用環形結構，用指針來減少對鏈表的操作，增加效率。

當發生缺頁中斷時，算法首先檢查表指針指向的頁面，如果它的R位是0就淘汰該頁面，並把新的頁面插入這個位置，然後把指針往後移一個位置；如果R位是1就清除R位並把表指針後移一個位置，直到找到一個R位為0的頁面為止。

![image-20200726102318173](D:\google\電子書\學習筆記\image-20200726102318173.png)

### 3.4.6 最近最少使用頁面置換算法

LRU(Least Recently Used)，已經很久沒使用的頁面，在未來較長的時間內仍然不會被使用。

有一個硬體實現LRU的方法。在一個有n個頁框的機器中，LRU硬體可以維持一個初值為0 的n×n的矩陣。當訪問到頁框k時，硬體首先把k行的位都設置成1，再把k列的位都設置成0。在任何時刻，二進制數值最小的行就是最近最少使用的。

### 3.4.7 用軟體模擬LRU

使用老化算法計算哪個頁面的使用較少。

### 3.4.8 工作集頁面置換算法

請求調頁：進程需要的頁面只有需要才調入，而不是預先裝入。

一個進程當前正在使用的頁面的集合或為它的`工作集(working set)`。否果整個工作集都被裝入到了記憶體中，那麼進程在運行到下一運行階段之前，不會產生很多缺頁中斷。若記憶體太少而無法容納下整個工作集，那麼進程的運行過程中會產生大量的缺頁中斷，導致運行速度也會變得很緩慢。

若每執行幾條指令程式就發生一次缺頁中斷，那麼就稱這個程式發生了顛簸(thrashing)

在多道程序設計中，進程經常需要重新載入記憶體中。這樣會因為需要多次的缺頁中斷才能將一個程式載入，而導致CPU時間浪費。

工作集模型就是要設法解決這個問題，它會追踨進程的工作集，以確保進程運行以前，它的工作集就已在記憶體中了。它的結果使得缺頁中斷率大幅減少。讓進程運行前預先裝入其工作集頁面稱為`預先調頁(prepaging)`

工作集是隨著時間變化的，我們把工作集w，與記憶體訪問次數k、時間t，寫成一個關係，w(k, t )。

在一個k=1的訪問中，一定包含k>1次的訪問的頁面，所以w(k, t )是k的單調非遞減函數。隨著k的變大，w(k, t)是不會無限變大的，因為程序不可能訪問比它的地址空間所能容納的頁面數目上限還多的頁面，且幾乎沒有程式會使用每個頁面。

因為工作集隨時間變化很慢，那麼當程式重新開始時，就有可能根據它上次結束時的工作集對要用的頁面做一個合理的推測，預先調頁就是在程式繼續運行之前預先裝入推測出的工作集頁面。

為了算出工作集，我們考慮執行時間，也就是定義過去10ms中的記憶體訪問所用到的頁面的集合。每個進程只計算它自己的執行時間，也稱作`當前實際運行時間`。進程的工作集就是過去τ秒實際運行時間中它所訪問的頁面的集合。

工作集頁面置換算法的基本思想就是找出一個不在工作集中的頁面並淘汰之。

這個算法中會使用上次使用時間以及R(訪問位)來決定是否淘汰一個頁面。

在處理每個頁面時，都需要檢查R位。如果它是1，就把當前實際時間寫進頁表項的上次使用時間。

如果R是0，那麼表示在當前時鐘滴答中，該頁面還沒有被訪問過，則它就可以作為候選者。為了知道它是否應該置換，需要計算它的生存時間(即當前實際運行時間減去上次使用時間)，然後與τ做比較。如果它的生存時間大於τ，那麼這個頁面就不再在工作集中，而用新的頁面置換它。

如果R是0同時生存時間小於或等於τ，則該頁面仍然在工作集中。這樣就要把該頁面臨時保留下來，但是要記錄生存時間最長(上次使用時間的最小值)的頁面。如果掃描完整個頁表卻沒有個R=0的頁面，就淘汰生存時間最長的頁面。

在最壞情況下，在當前時間滴答中，所有的頁面都被訪問過了(也就是都有R=1)，因此就隨機選擇一個頁面淘汰，如果有的話最好選一個乾淨頁面。

### 3.4.9 工作集時鐘頁面置換算法

因為需要整個頁表才能確定被淘汰的頁面，因為基本工作集算法是比較費時的。所以要改進它，基於時鐘算法，並且使用了工作集信息，稱為WSClock(工作集時鐘)算法

這是一個以頁框為元素的循環表，

最初該表是空的。當裝入第一個頁面後，把它加到該表中。隨著更多的頁面的加入，它們形成一個環。每個表包含來自基本工作集算法的上次使用時間，以及R位(已標明)和M位(未標明)

![image-20200726211241412](D:\google\電子書\學習筆記\image-20200726211241412.png)

## 3.5 分頁系統中的設計問題

### 3.5.1 局部分配策略與全局分配策略

局部算法會導致大量的空閒記憶體存在。

全局算法系統必須不停地確定應該給每個進程分配多少頁框。

一種方法是監測工作集的大小，工作集大小由老化指出，但無法防止顛簸。

另一種是使用進程分配頁框的算法。其中一種是定期確定進程運的數目並為它們分配相等的份額。但對使用大小不同的進程來說這種分配很不合理。

可依進程的大小比例分配頁面，但分配必須在程式運行時動態更新。使用一種PFF(Page Fault Frequency, 缺頁中斷率)算法，僅指出增加或減小分配給進程的頁面，但不說明換掉哪個頁面。

有些頁面置換算法只有採用局部算法才有意義，例如工作集或是WSClock算法，是針對某些特定進程而且必須應用在這些進程的上下文中。

### 3.5.2 負載控制

一旦所有進程的組合工作集超出了記憶體容量，就可能發生顛簸。因為沒有進程需要更少的記憶體。所以只能強迫一些進程暫時從記憶體中去掉。

減小競爭的方式是將一部分進程交換到磁盤，並釋放他們所占有的所有頁面。當一個進程被交換到磁盤後，它的頁框可以被其他處於顛簸狀態的進程分享。如果顛簸停止，系統就能夠這樣運行一段時間。如果顛簸繼續，就需要繼續交換其它進程。

### 3.5.3 頁面大小

考慮頁面大小，內部碎片。在記憶體中有n個段、頁面大小為p字節時，會有np/2字節被內部碎片浪費。這樣考慮，使用小頁面更好。

小頁面也使更少無用程式留在記憶體中，減小浪費。

但小頁面也代表需要更多頁面，也說明需要更大的頁表。一個32kb的程式只需要4個8kb的頁面，卻需要64 個512字節的頁面。

記憶體與硬碟的傳輸一般是一次一頁，大部分時間都花在了尋道和旋轉延遲，所以傳輸小頁面和傳輸大頁面的時間基本上是相同的。裝入64個512字節的頁面需要64×10ms，而裝入4個8kn的頁面需要4×12ms

進程平均大小是s個字節，頁面大小是p個字節，頁表項需要e個字節。

最優頁面大小的公式為：P = 2se^1/2^

對於s=1MB和每個頁表項e=8個字節，最優頁面大小是4kb。

### 分離的指令空間和數據空間

指令空間：I空間

數據空間：D空間

這種設計對兩種空間都可以進行分頁，而且互相獨立。分別使用自己的頁表，分別完成虛擬頁面到物理頁面的映射。

這個設計不復雜，也能使可用的地址空間加倍。

### 共享頁面

在大型多道程序設計系統中，幾個不同的用戶同時運行同一個程序是很常見的，也可以避免一個頁面有兩個副本。但不是所有頁面都適合共享。只讀的頁面可以共享，數據頁面不能共享。

如果系統支持分離的I空間及D空間，那麼共享程式就會很簡單了。

實現：

每個進程會有兩個指針：一個指向I空間頁表，一個指向D空間頁表。調度程式選擇進程運行時，使用這些指針來定位合適的頁表，並使用它們來設立MMU。

![image-20200728120321035](D:\google\電子書\學習筆記\image-20200728120321035.png)

沒有使用I空間和D空間也可以共享程式(有時稱為庫)。

共享頁面需要有專門的數據結構來記錄，防止其他共享進程對頁面做了移動。

共享數據也可以透過寫時複制來實現，也就是在寫入數據時，觸發陷阱，並且建立一個數據頁面副。之後的寫入操作就不會再觸發陷阱。

### 3.5.6共享庫

共享庫並不是一次性地讀入記憶體。而是根據需要，以頁面為單位裝載的，因此沒有被調用到的函數是不會被裝載到記憶體中的。

如果共享庫因為修正了一個bug被更新了，那麼並不需要重新編譯調用了這個函數的程式。這個特性對商業軟體來說十分重 ，因為商業軟體的源碼不會分發給客戶。

共享庫需要解決地址映射的問題，因為映射是統一由MMU從虛擬地址映射到物理地址。所以在編譯共享庫時，用一個特殊的編譯選項告知編譯器，不要產生絕對地址的指令，只能產生相對地址的指令。這稱為位置無關代碼。

### 3.5.7 記憶體映射文件

共享庫是記憶體映射文件的一個特例。

其思想是：進程可以通過發起一個系統調用，將一個文件映射到其虛擬地址空間的一部分。

記憶體映射文件提供了一種I/O的可選模型。可以把一個文件當作一個記憶體中的大字符數組來訪問，而不通過讀寫操作來訪問這個文件。

如果兩個以上或兩個以上的進程同時映射了同一個文件，它們就可以通過共享空間來通信。一個進程在共享記憶體上完成了寫操作，此刻當另一個進程在映射到這個文件的虛擬地址空間上執行讀操作時，它就可以立刻看到上一個進程寫操作的結果。這個機制提供了一個進程之間的高帶寬通道。

很顯然，如果記憶體映射空間可用，共享庫就可以使用這個機制。

### 3.5.8 清除策略

為保證有足夠的空閒頁框，很多分頁系統有一個稱為分頁守護進程(paging daemon)的後台進程，大多數時候在睡眠，會定期被喚醒以檢查記憶體的狀態。如果空閒頁框過少，分頁守護進程通過預定的頁面置換算選擇頁面換出記憶體。頁面有修改過，將寫回硬碟。

分頁守護進程會保證所有的空閒頁框是乾淨的，當需要使用一個已被淘汰的頁面時，如果該頁框還沒有被覆蓋，將其從空閒頁框緩沖池中移出即可恢復該頁面。保存一定數目的頁框供給比使用所有記憶體並在需要時搜索一個頁框有更好的性能。

實現的方法是雙指針時鐘。前指針由分頁守護進程控制。當它指向一個髒頁面時，就把能頁面寫回硬碟，前指針向前移動。當它指向一個乾淨頁面時，僅後指針向前移動。後指針用於頁面置換，就像在標準時鐘算法中一樣。由於分頁守護進程的工作，後指針命中乾淨頁面的概率會增加。

### 3.5.9 虛擬記憶體接口

允許程序員對記憶體映射進行控制可讓多個進程共享一部分記憶體。

對記憶體進行命名，就可以實現共享記憶體。通過讓一個進程把一片記憶體區域的名稱通知另一個進程，而使得第二個進程可以把這片區域映射到它的虛擬地址空間中。這樣就實現了共享記憶體。

分布式共享記憶體：該方法允許網路上多個進程共程一個頁面集合，這些頁面可能(非必要)作為單個的線性共享地址空間。當一個進程訪問當前還沒有映射進的頁面時，就會產生缺頁中斷。在內核空間或者用戶空間中的缺頁中斷處理程序就會對擁有該頁面的機器進行定位，並發出請求，讓它清除該頁面的映射，並通過網路發送出來。當頁面到達時，就把它映射進來，並重新開始運行引起缺頁中斷的指令。

## 3.6 有關實現的問題

### 3.6.1 與分頁有關的工作

* 進程創建時：
  * 確定程式和數據在初始時有多大，並創建頁表。
  * 在記憶體中為頁表分配空間。
  * 在硬碟中分配空間，以便在一個進程換出時儲存在硬碟的這個空間
  * 用程式正文和數據對交換區進行初始化，當缺頁中斷時，可以調入新的頁面。
* 進程進行時：
  * 為下一個進程重置MMU，刷新TLB，也就是清除以前的進程。
  * 通過復制或將頁表指針放入硬體寄存器，使新進程的頁表成為當前頁表
* 缺頁中斷時：
  * 操作系統必須通過讀該硬體寄存器來確定是哪個虛擬地址造成了缺頁中斷。
  * 計算需要哪個頁面，並在硬碟上對該頁面進行定位。
  * 找到合適的頁框來存放新頁面，必要時還要更換老的頁面，然後把所需的頁面讀入頁框。
  * 退出程序計數器，使程序計數器指向引起缺頁中斷的指令，重新執行該指令。
* 進程中止時：
  * 操作系統必須釋放進程的頁表、頁面和頁面在硬碟上的空間。
  * 如果頁面是共享的，只有當全部進程都停止時，才會釋放記憶體和硬碟上的頁面。

### 3.6.2 缺頁中斷處理

缺頁中斷時發生的事件順序：

一) 硬體陷入內核，在堆棧中保留程序計數器。大多數機器將當前指令的各種狀態信息保存在特殊的CPU寄存器中。

二) 啟動一個匯編代碼例程保存通用寄存器和其他易失的信息，以免被操作系統破壞。這個例程將操作系統作為一個函數調用

三) 當操作系統發現一個缺頁中斷時，嘗試發現需要哪個虛擬頁面。通常一個硬體寄存器會有這一個訊息。如果沒有，操系統必須檢索程序計數器，取出這條指令，用軟體分析這條指令，看看它在缺頁中斷時止在做什麼。

四) 一旦知道發生缺頁中斷的虛擬地址，操作系統檢查這個地址是否有效，並檢查存取與保護是否一致。如果不一致，向進程發出一個信號或殺掉該進程。如果地址有效且沒有保護錯誤發生，系統則檢查是否有空閒頁框。如果沒有空閒頁框，執行頁面置換算法。

五) 如果選擇的頁面髒了，安排該頁寫回硬碟，並發生一次上下文切換，掛起產生缺頁中斷的進程，讓其他進程運行直至硬碟傳輸結束。該頁框須要標記為忙，以免因為其他原因而被其他進程占用。

六) 一旦頁框乾淨後，操作系統查找所需頁面在硬碟上的地址，通過硬碟將其裝入。該頁面正被裝入時，產生缺頁中斷的進程仍然掛起，並且運行其他用戶的進程。

七) 當硬碟中斷發生時，表明該頁已經被裝入，頁表已經更新可以反映它的位置，頁框也被標記為正常狀態。

八) 恢復發生缺頁中斷的進程，程序計數器重新指向這條指令

九)調度引發缺頁中斷的進程，操作系統返回調用它的匯編語言例程

十) 該例程恢復寄存器和其他狀態信息，返回到用戶空間繼續執行，就好像缺頁中斷沒有發生過一樣。

### 3.6.3 指令備份

### 3.6.4 鎖定記憶體中的頁面

如果分頁算法是全局算法，包含I/O緩沖區的頁面會有很小的機會被選中換出記憶體。

因此將頁面釘住(pinning)或是在內核緩沖區中完成所有的I/O操作可以保證正在進行I/O的進程不會被移出記憶體。

### 3.6.5 後備存儲

在硬碟上分配頁面空間最簡單的方法是在硬碟上設置特殊的交換分區(swap)，甚至從文件系統劃分一塊獨立的硬碟。

系統啟動時，該交換分區為空，並在記憶體中以單獨的項給出它的起始和大小。第一個進程啟動時，留出與這個進程一樣大的交換區塊，剩餘的為總空間減去這個交換分區。當新進程啟動後，它們同樣被分配與其核心映像同樣大小的交換分區。

進程結束後，會釋放其硬碟上的交換分區。

每個進程對應的是其交換區的硬碟地址，即進程映像保存的地方。這一信息是記錄在進程表裡。為回地址時，將虛擬地址空間中頁面的偏移量加到交換區的開始地址。

進程啟動前的初始化，一是將整個進程映像複制到交換區，一是將整個進程裝入記憶體，並在需要時換出。

因為數據可能會增長。所以，正文、數據和堆棧分別保留交換區，並允許這些交換區在硬碟上多於一個塊。

另一個方法是不使用交換區，進程中記錄相應的硬碟地址。頁面換出時才分配硬碟空間，並在換入時回收硬碟空間。

### 3.6.6 策略和機制的分離

將存儲管理機制分成三部份：

1) 一個底層MMU處理程序

2) 一個作為內核一部份的缺頁中斷處理程序

3) 一個運行在用戶空間中的外部頁面調度程序

![os-graph3-29.jpg](D:\google\電子書\學習筆記\os-graph3-29.jpg)

## 3.7 分段

在編譯器編譯過程中，會產生許多表：包括程式正文、符號表、語法分析樹、常量表、調用堆棧

這些表如果視為獨立的段，可以減少這些表有可能的不同大小的狀況。

段是一段從0到某個允許的最大值之間的任何一個值。不同的段長度可以不同，且通常情況下也都不同。段的長度在運行期間可以動態改變。

要在這種分段或二維的存儲器中指非一個地址，程序必須提供兩部份地址，一個段號和一個段內地址。

一個段可能是一個過程、一個數組、一個堆棧、一個數值變量，但它不會同時包含多種不同類型的內容。

分段有助於共享庫和數據。

### 3.7.1 純分段的實現

在原本的段中，取代了較小的段，就會留下許多棋盤型碎片，可通過記憶體緊縮來解決。

### 3.7.2 分段和分頁結合：MULTICS

如果一個段比較大，保存到記憶體中可能不方便，因此需要對他分頁。

MULTICS把每個分頁視為一個虛擬記憶體並對它進行頁，以結合分頁的優點(統一的頁面大小和在只使用段的一部分時不用把它全部調入記憶體)和分段的優點(易於編程、模塊化、保護和共享)

每個MULTICS程式都有一個段表，每個段表對應一個描述符。因為段表可能會有25萬多個表項，段表本身也是一個段並被分頁。一個段描述符包含了一個段是否在記憶體中的標誌，只要一個段的任何一個部分在記憶體中就被認為是在記憶體中，並且它的頁表也會在記憶體中。

![os-graph3-34.jpg](D:\google\電子書\學習筆記\os-graph3-34.jpg)

