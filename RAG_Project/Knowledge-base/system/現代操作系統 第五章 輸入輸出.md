# 第五章 輸入/輸出

## 5.1 I/O硬體原理

### 5.1.1 I/O設備

可分成

**塊設備**：把資料儲存在固定大小的塊中，每個塊都有自己的地址。通常塊的大小有512字節到65536字節之間。所有傳輸以一個或多個完整的（連續的）塊為單位。

每個塊都能獨立於其他塊而讀寫。

硬碟、光碟片和USB是最常見的塊設備。

**字符設備**：字符設備以字符為單位發送或接收一個字符流，而不考慮任何塊結構。字符設備是不可尋址的，也沒有任何尋道操作。印表機、網路接口、滑鼠，以及大多數與硬碟不同的設備都可看作字符設備。

### 5.1.2 設備控制器

I/O設備通常分為機械部件或是電子部件

I/O設備的電子部位稱為`設備控制器`或`適配器`。通常以主板上的芯片，或者以插入（PCI）擴展槽中的印刷電路板的形式出現。

機械部件就是設備本身。

控制器與設備之間的接口通常是一個很低層次的接口。例如硬碟可以按每個磁道2000000個扇區，每個扇區512字節進行格式化。但，實際從驅動器出來的卻是一個串行的位流，它以一個前導符（preamble)開始，接著是一個扇區中的4096位，最後是一個校驗和，也稱錯誤校正碼（Error-Correcting Code, ECC)。前導符是在對硬碟進行格式化時寫上去的，它包括柱面數和扇區號、扇區大小以及類似的數據，此外還包括同步信息。

控制器的任敉是把串行的位流轉換為字節塊，並進行必要的錯誤校正工作。字節塊通常首先在控制器內部的一個緩沖區中按位進行組裝，然後再對校驗和進行校驗並證明字節塊沒有錯誤後，再將它複制到主存中。

LCD螢幕的控制器也是一個串行設備，從記憶體中讀入包含待顯示字符的字節，產生信號以便使相應的像素放變背光的極化方式，從而將其寫到螢幕上。

### 5.1.3 記憶體映射I/O

每個控制器有機個寄存器用來與CPU進行通信。通過寫入這些寄存器，操作系統可以命令設備發送數據、接收數據、開啟或關閉，或者執行某些其他操作。通過讀取這些寄存器，操作系統可以了解設備的狀態，是否準備好接收一個新的命令等。

除了這些控制寄存器以外，許多設備還有一個操作系統可以讀寫的數據緩沖區。例如，在屏幕上顯示像素的常規方法是使用一個影像RAM，這一個RAM基本上只是一個數據緩沖區，可供程序或操作系統寫入數據。

CPU與設備的控制寄存器和數據緩沖區進行通信的方法：

一、每個控制寄存器被分配一個I/O端口號，這是一個8位或16位的整數。所有I/O端口形成I/O端口空間，並且受到保護使得普通的用戶程序不能對其進行訪問（只有操作系統可以訪問），使用這個指令：

IN REG, PORT ：CPU讀取控制寄存器port的內容並將結果存入到CPU寄存器REG中

OUT PORT, REG：CPU將REG中的內容寫內到控制寄存器中。

二、PDP-11引入的，將所有控制寄存器映射到記憶體空間中，每個控制寄存器被分配唯一的一個記憶體地址，並且不會有記憶體被分配到這一地址。這稱為記憶體映射I/O（memory-mapped I/O)。通常將分配的地址放在記憶體的頂端。

記憶體映射的優點：

1. 對於記憶體映射I/O，設備控制寄存器只是記憶體中的變量，在C語言中可以和任何其他變量一樣尋址。因此，I/O設備驅動可以完全用C語言編寫。如果不使用記憶體映射I/O，就要用到某些匯編代碼。
2. 不需要特殊的保護機制來阻止用戶進程執行I/O操作。操作系統必須要做的全部事情只是避免把包含控制寄存器的那部份地址空間放入用戶的虛擬地址空間中。操作系統只要簡單地通過在其頁表中包含期望的頁面就可以讓用戶控制特定的設備而不是其他設備。這樣可以使不同的設備驅動程式放置在不同的地址空間中，不但可以減小內核的大小，且防止驅動程式之間互相干擾。
3.  可以引用記憶體的每一條指令也可以引用控制寄存器。

硬體必須能夠針對每個頁面有選擇性地禁用高速緩存。

在具有單獨的記憶體總線中，I/O設備沒有辦法查看記憶體地址，因為記憶體地址旁路到記憶體總線上，無法響應。

解法：

一：將全部記憶體引用發送到記憶體，如果記憶體響應失敗，CPU將嘗試其他總線。

二：在記憶體上放置一個探查設備。

三：在記憶體控制器中對地址進行過濾。記憶體控制器在預裝載時，會告訴範圍寄存器，640K到1M-1可能被標記為非記憶體範圍，而是保留給設備的記憶體範圍。

### 5.1.4 直接存儲器存取

使用直接存儲器（Direct Memory Access, DMA)，減少CPU時間的浪費。

假設CPU通過總線連接記憶體和I/O設備。只有硬體具有DMA控制器時操作系統才能使用DMA，而大多數系統都有DMA控制器。DMA控制器通常是集成到主機板上。

無論DMA控制器物理上處於何處，它都能夠獨立於CPU而訪問系統總線。

DMA包含：

* 記憶體地址寄存器
* 字節計數寄存器
* 控制寄存器：指定要使用的I/O端口、傳送方向（從I/O設備讀或寫到I/O設備）、傳送單位（每次一個字節或每次一個字），以及在一次突發傳送中要傳送的字節數。

![image-20200803090209122](/home/jackyfeng/GoogleDrive/電子書/學習筆記/image-20200803090209122.png)

DMA工作原理：

1. CPU通過設置DMA控制器的寄存器對它進行編程，所以DMA知道將什麼數據傳送到什麼地方。DMA控制器還要向硬碟控制器發出一個命令，通知它從硬碟讀數據到其內部的緩沖區中，並且對校驗和進行檢驗。如果硬碟控制器的緩沖區中的數據是有效的，那麼DMA就可以開始了。
2. DMA在總線上發出一個讀請求到硬碟控制器而發起DMA傳送。要寫的記憶體地址在總線的地址線上，所以當硬碟控制器從其內部緩沖區中讀取下一個字的時候，它知道將該字寫到什麼地方。
3. 寫到記憶體
4. 硬碟控制器發出一個應答信號到DMA控制器。於是DMA控制器步增要使用的記憶體地址，並且步減字節計數。如果字節計數仍然大於0 ，則重複第2步到第4步，直到字節計數到達0。此時，DMA控制器將中斷CPU以便讓CPU知道傳送現在已經完成了。當操作系統開始工作時，不用將硬碟塊複制到記憶體中，因為它已經在記憶體中了。

飛越模式（fly-by mode)：DMA控制器通知設備控制器直接將數據傳送到主存。

### 5.1.5 重溫中斷（Interrupts Revisited）

![image-20200803090209122](/home/jackyfeng/GoogleDrive/電子書/學習筆記/os-graph5-5.jpg)

當一個I/O設備完成交給它的工作時，它就產生一個中斷（假設操作系統已經開放中斷），它是通過在分配給它的一條總線信號線上置起信號而產生中斷的。該信號被主機板上的中斷控制器芯片檢測到，由中斷控制芯片決定做什麼。

如果沒有其他的中斷，中斷控制器將立刻對中斷進行處理。如果有更高級別的中斷請求，該設備將暫時不被理睬。這種情況下，該設備將繼續在總線上置起中斷信號，直到得到CPU的服務。

為了處理中斷，中斷控制器在地址線上放置一個數字表明哪個設備需要關注，並置起一個中斷CPU的信號。中斷信號導致CPU停止當前正在做的工作並開始做其他事情。

地址線上的數字被用做指向一個稱為中斷向量（interrupt vector)的表格的索引，以便讀取一個新的程序計數器。這一個程序計數器指向相應的中斷服務過程的開始。

中斷服務過程開始運行後，它立刻通過將一個確定的值寫到中斷控制器的某個I/O端口來對中斷做出應答。這一應答告訴中斷控制器可以自由地發出另一個中斷。通過讓CPU延遲這一應答直到它準備好處理下一個中斷，就可以避免與多個幾乎同時發生的中斷相牽涉的競爭狀態。

在開始服務程式之前，硬體總是要保存一定的信息。

至少要保存程序計數器，這樣被中斷的進程才能夠重新開始。所有可見的寄存器和很多內部寄存器或許也要保存。

至於保存位置有兩種選擇：

一：內部寄存器中，但這一方法可能讓中斷控制器無法得到應答，直到所有可能的相關信息被讀出。在所有資訊讀出之前，系統會呈現死機的狀態。

二：在堆棧中保存信息。如果使用用戶的堆棧，堆棧指針也可能不是合法的，指針可能指向一個頁面的末端。

使用內核堆棧，堆棧指針是合法的且指向一個固定的頁面。但切換到核心態可能要求改變MMU上下文，並可能使高速緩存和TLB的大部份或全部失效。靜態或動態裝載所有這些東西將增加處理一個中斷的時間，因而浪費CPU的時間。

#### 精確中斷和不精確中斷

在流水線中有指令時，發生中斷就有可能會有指令是處於執行中的狀態，而導致程序計數器無法正確的反映指令的邊界

精確中斷是將機器留在一個明確狀態的中斷，具有4 個特性：

1）PC（程序計數器）保存在一個已知的地方

2）PC所指向的指令之前的所有指令已經完全執行

3）PC所指向的指令之後的所有指令都沒有執行

4）PC所指向的指令的執行狀態是已知的

對於PC所指向的那些指令來說，此處並沒有禁止它們執行，而只是要求在中斷發生之前必須撤銷它們對寄存器或記憶體所做的任何修改，指令只有已執行及未執行兩種狀態。

如果中斷是一個I/O中斷，那麼指令就還沒開始執行。如果中斷是一個陷阱或者頁面故障，那PC指向導致錯誤的指令，所以以後可以重新開始執行。



不滿足這些要求的中斷稱為不精確中斷（imprecise interrupt)。中斷時，需要保存內部大量的狀態到堆棧中，從而使操作系統有可能判斷出正在發生什麼事情。也因為中斷時大量的信息保存在記憶體中，使得中斷響應十分緩慢，而恢復則更加糟糕。

有些計算機設計成某些種類的中斷和陷阱是精確的，而其他不是

有些計算機具有一個位，可以設置它強迫所有的中斷都是精確的。設置這一位的不利之處是，它強迫CPU仔細地將正在做的一切事情記入日誌並維護寄存器的影子副本，這樣才能在任意時刻生成精確中斷。

## 5.2 I/O軟體原理

### 5.2.1 I/O軟體的目標

關鍵概念是設備獨立性：可以訪問任意I/O設備而無需事先指定設備。例如，讀取一個文件作為輸入的程式應該能夠在硬碟、DVD或者USB盤上讀取文件，無需為每一種不同的設備修改程序

統一命名（uniform naming)：一個文件或一個設備的名字應該是一個簡單的字符串或一個整數，不應該依賴於設備。在UNIX系統中，所有存儲盤都能以任意方式集成到文件系統層次結構中，用戶不必知道哪個名字對應於哪台設備。例如USB盤mount到目錄/usr/ast/backup下，這樣一來只要文件放到/usr/ast/backup，就是將文件放到USB盤中。

錯誤處理(error handling)：一般來說，錯誤處理應該盡可能在接近硬體的層面得到處理。當控制器發現了一個讀錯誤時，就應該自己設法糾正這一錯誤。如果不行，設備驅動程序應當予以處理，可能只需重讀一次這塊數據就正確了。

同步（synchronous, 阻塞）和異步（asynchronous, 中斷驅動）傳輸。大多數物理I/O是異步的--CPU啟動傳輸後便轉去做其他工作，直到中斷發生。如果I/O是阻塞的，那麼用戶程式就更加容易編寫--在read系統調用之後，程式將自動被掛起，直到緩沖區中的數據準備好。

緩沖（buffering）：數據離開一個設備之後，通常並不能直接存放到其最終目的地。例如，網路上進來一個數據包時，直到將該數據包存放在某個地方並對其進行檢查，操作系統才知道要將其置於何處。緩沖涉及大量的複制工作，並且經常對I/O性能有重大影響。

共享和獨占設備的問題。

### 5.2.2 程序控制I/O

最簡單的實現方式。考慮一個用戶進程，該進程想通過串行接口在印表機上列印8個字符的字符串"ABCDEFGH"。

1. 首先要在用戶空間的一個緩沖區中組裝字符串
2. 用戶進程通過發出打開印表機一類的系統調用獲得印表機以便進行寫操作。
3. 如果印表機被另一個進程占用，該系統調用將失敗並返回一個錯誤代碼，或者將阻塞直到表印機可用，具體情況取決於操作系統和調用參數。
4. 一擁有印表機，用戶進程就將發出一個系統調用通知操作系統在打印機上列印字符串。

一旦將第一個字符複制到印表機，操作系統就要查看酪表機是否就緒準備接收另一個字符。

操作簡要總結：

1）數據被複制到內核空間。

2）操作系統進入一個循環，一次輸出一個字符。

3）CPU查詢設備以了解它是否就緒準備接收另一個字符。稱為輪詢(polling)或忙等待（busy waiting)

### 5.2.3 中斷驅動I/O

使用中斷讓CPU進行更有效的利用。

CPU調用調度程序，並且某個其他進程將運行。

```
copy_from_user(buffer, p, count);
enable_interrupts();
while (*printer_status_reg != READY);
*printer_data_register = p[0];
scheduler();
```

印表機中斷服務的過程。

```
if(count == 0){
	unblock_user();
}else {
	*printer_data_register = p[i];
	count = count - 1;
	i = i + 1;
}
acknowledge_interrupt();
return_from_interrupt();
```

中斷驅動I/O的缺點是中斷發生在每一個字符上。中斷要花時間，所以這一方法將浪費一定數量的CPU時間

### 5.2.4 使用DMA的I/O

讓DMA控制器一次發給印表機提供一個字符，而不必打擾CPU。本質上DMA是程序控制I/O，只是由DMA控制器而不是主CPU做全部工作。需要特殊的硬體，但是使CPU獲得自由從而可以在I/O期間做其他工作。

## 5.3 I/O軟體層次

分為四個層次：中斷處理程序、設備驅動程序、與設備無關的操作系統軟體、用戶級I/O軟體

### 5.3.1 中斷處理程序

可能需要的步驟：

1）保存沒有被中斷硬體保存的所有寄存器（包括PSW）

2）為中斷服務過程設置上下文，可能包括設置TLB、MMU和頁表。

3）為中斷服務過程設置堆棧

4）應答中斷控制器，如果不存在集中的中斷控制器，則再次開放中斷

5）將寄存器從它們被保存的地方（可能是某個堆棧）複制到進程表

6）運行中斷服務過程，從發出中斷的設備控制器的寄存器中提取信息

7）選擇下一次運行哪個進程，如果中斷導致某個被阻塞的高優先級進程變成就緒，則可能選擇它現在就運行

8）為下一次要運行的進程設置MMU上下文，也許還需要設置某個TLB

9）裝入新進程的寄存器，包括其PSW

10）開始運行新進程

中斷處理需要相當多的CPU指令，特別是存在虛擬記憶體並且必須設置頁表或者必須保存MMU狀態（例如R和M位）的機器上。

### 5.3.2 設備驅動程式

每個連接到計算機上的I/O設備都需要某些設備特定的代碼來對其進行控制，這個代碼稱為設備驅動程式。一般由設備的製造商編寫並隨同設備一起交付。

每個設備驅動程式通常處廷一種類型的設備，或者至多處痛一種緊密相關的設備。

USB驅動程式通常是堆棧式的，就像是網路中的TCP/IP棧。在底層，USB鏈路層（串行I/O），這一層處理硬體事務，例如發信號以及將信號流譯碼成USB包。這一層被較高的層次所使用，而這些較高的層次則處理數據包以及被大多數設備所共享的USB通用功能。在頂層我們會發現高層API，例如針對大容量存儲設備和照相機等的接口。因此我們依然擁有分開的設備驅動程式，盡管它們共享部分協議棧。

設備驅動程式通常必須是操作系統內核的一部分

實際上，驅動程式運行在用戶空間中，使用系統調用來讀寫設備寄存器。這一設計使內核與驅動程式相隔離，並使驅動程式之間相隔離，可以消除系統崩潰的一個主要源頭---有問題的驅動程式干擾內核。

設備驅動程式一般結構。

1. 啟動時檢查輸入參數，目的是搞清楚它們是有效的，如果不是，則返回一個錯誤。參數有效，則可能需要進行從抽象事項到具體事項的轉換。對硬碟驅動程式來說，這可能意味著將一個線性的硬碟塊號轉換成硬碟幾何布局的磁頭、磁道、扇區和柱面號。
2. 檢查設備是否使用中。使用中則排入隊列以備稍後處理。空閒的話，驅動程式將檢查硬體狀態以了解請求現在是否能夠得到處理。在傳輸開始之前，可能需要接通設備或啟動馬達。一旦設備接通並就緒，實際的控制就可以開始工作了。
3. 根據控制設備必須要做的工作，由驅動程式處確定命令序列。驅動程式在獲知哪些命令將要發出之後，就開始將它們寫入控制器的設備寄存器。
4. 檢測控制器是否已經接收命令並準備好接收下一個命令。這個動作會持續到所有命令發出為止。對於某些控制器，可以為其提供一個在記憶體中的命令鏈表，並告訴它自己去讀取並處理所有命令而不需要操作系統提供進一步幫助
5. 命令發出後，會牽涉到兩種情形。一，設備驅動程式必須等待，直到控制器為其做某些事情，所以驅動程式將阻塞自身直到中斷來解除阻塞。二，操作無延遲的完成，所以驅動程式不需要阻塞。例如在字符模式下滾動屏幕只要少許字節到控制器的寄存器中，由於不用機械運動，所以整個操作可以在幾個ns內完成。

更複雜的因素：

1. 有可能一個正在運行的驅動程式必須預料到在第一次調用完成之前第二次被調用，這叫重入的（reentrant)
2. 在可熱插拔的系統中，有可能一個設備正在忙於讀數據時，系統通知它用戶突然將設備從系統中刪除了。當前I/O傳送必須中止且不能破壞任何核心數據結構，且任何與這個設備相關的請求都必須適當的刪除，同時還要為它們的調用者提供這一個壞消息。

驅動程式不允許系統調用，但允許對某些內核過程調用。例如調用內核過程來分配和釋放硬接線的記憶體頁面作為緩沖區。

### 5.3.3 與設備無關的I/O軟體

與設備無關的I/O軟體功能

一些本來應按照與設備無關方式實現的功能，出於效率和其他原因，實際上是由驅動程式來實現的。

與設備無關的軟體的基本功能是執行對所有設備公共的I/O功能，並向用戶層軟體提供一個統一的接口

#### 設備驅動程式的統一接口

達成使所有I/O設備和驅動程式看起來或多或少是相同的，如果硬碟、印表機、鍵盤等接口方式都不相同，那麼每次在一個新設備出現時，都必須為新設備修改操作系統，這不是一個好主意。

如果所有的驅動程式都有相同的接口，添加一個新的驅動程式就變得容易多了。這也意味著驅動程式的編寫人員知道驅動程式的接口應該是什麼樣子的。

這種設計就是對每一種設備類型，例如硬碟或印表機，操作系統定義一組驅動程式必須支持的函數。

* 硬碟：函數包含讀、寫，開啟和關閉電源、格式化及其他與硬碟有關的事情。

驅動程式通常包含一張表格，這張表格具有針對這些函數指向驅動程式自身的指針。當驅動程式裝載時，操作系統記錄下這張函數針指表的地址，所以當操作系統需要調用一個函數時，它可以通過這張表格發出間接調用。這張函數指針表定義了驅動程式與操作系統其餘部分之間的接口。

給I/O設備命名是統一接口問題的另一個方面，與設備無關的軟體要負責把符號化的設備名映射到適當的驅動程式上。

**主設備號（major device number)**：例如/dev/disk0這個設備名確定了一個特殊文件的i節點。用於定位相應的驅動程式。所有驅動程式都是通過使用主設備號來選擇驅動程式而得到訪問。

**次設備號(minor device number)** ：作為參數傳遞給驅動程式，用來確定要讀或寫的具體單元。

命名也可以用訪問權限設置適當的安全性。

#### 緩沖

考慮ADSL中，讓用戶進程執行read系統調用並阻塞自己以等待字符的到來。

* **無緩沖**：每個字符的到來都產生中斷，中斷服務過程負責將字符遞交給用戶進程並將阻塞解除。用戶進程把字符放到某個地方之後再對另一個字符進行讀操作並再次阻塞。
* **用戶空間中的緩沖**：在用戶空間中提供一個n字節長的緩沖區，並且執行讀入n個字符的讀操作。中斷服務過程負責將到來的字符放入該緩沖區中直到緩沖區填滿，然後喚醒用戶進程。可能的缺點是：當一個字符到來時，如果緩沖區被分頁而調出了記憶體將會導至已經讀完的字符不見。最好是將緩沖區鎖在記憶體中，但有可能過多的緩沖區都鎖在記憶體中，使性能下降。
* **內核空間緩沖區**：在內核空間中讀出字符，填滿時，將包含用戶緩沖區的頁面調入記憶體，並且一次將內核緩沖區的內容複制到用戶緩沖區中。
* **雙緩沖**：使用兩組緩沖，一組緩沖正在複制時，另一組緩沖就繼續接收資料，第一組複制完成，就回頭接收資料。
* **循環緩沖區**：由一個記憶體區域和兩個指針組成。一個指針指向下一個空閒的字，新的數據可以放到此處。另一個指針指向緩沖區中數據的第一個字，該字尚未被取走。添加數據時，硬體將推進第一個指針，而操作系統在萬走並處理數據時推進第二個指針。兩個指針都是環繞的，當它們到達頂部時將回到底部。

#### 錯誤報告

錯誤在I/O上下文中比在其他上下文中要常見得多。發生錯誤時，操作系統必須盡最大努力對它進行處理。

* 編程錯誤：發生在一個進程請求不可能的事情時，例如寫入一個輸入設備。提供一個無效的緩沖區地址或其他參數。或是指定一個無效的設備（例如只有兩個硬碟，卻指定了硬碟3）。這種錯誤只需要返回一個錯誤代碼返回給調試者。
* 實際的I/O錯誤：試圖寫一個已經被破壞的硬碟塊，或者試圖讀一個已經關機的便攜式相機。

#### 分配與釋放專用設備

某些設備一次只能一個進程使用，例如印表機。可以先將檢查設備是否可用，如果不可用，就將進程堵塞。

#### 提供與設備無關的塊大小

將若干個扇區當作一個邏輯塊。高層軟體就只需處理抽象的設備，這些抽象設備全部都使用相同的邏輯塊大小，與物理扇區的大小無關。有些字符設備一次一個字節的交付他們的數據，而其他則交付較大的數據。

## 5.3.4 用戶空間的I/O軟體



## 5.4 盤

### 5.4.1 盤硬體

#### 1. 磁盤

磁盤被組成柱面，每一個柱面包含若干磁道，磁道數與垂直堆疊的磁頭相同。磁道分成若干扇區，硬碟上每條磁道上扇區的數目多達幾百個。磁頭數大約是1～16個。

IDE（Intergrated Drive Electronics）和SATA（serial ATA)盤上，磁盤驅動器本身包含一個微控制器，該微控制器承擔了大量的工作並且允許實際的控制器發出一組高級命令。控制器經常做磁道高速緩存、壞塊重映射以及更多的工作。

重疊尋道（overlapped seek）：同時控制兩個或多個驅動器進行尋道。

#### 2. RAID

Redundant Array of Inexpensive Disk(廉價磁盤冗餘陣列)

SLED：Single Large Expenseive Disk

基本思想是將一個裝滿了磁盤的盒子安裝到計算機（通常是一個大型伺服器），用RAID控制器替換硬碟控制器卡，將數據複制到整個RAID上，然後繼續常規的操作。可以把一個RAID視為一個SLED，但有更好的可靠性和更好的性能。

#### 3. 磁盤格式化

硬碟由一疊鋁的、合金的或玻璃組成，典型的直徑為3.5英寸或2.5英寸。

在磁盤能夠使用之前，必須經受軟體完成的低級格式化。該格式包含一系列同心的磁道，每個磁道包含若干數目的扇區，扇區間存在短的間隙。

一個磁盤扇區包含了：前導碼、數據、ECC

前導碼以一定的位模式開始，位模式使硬體得以識別扇區的開始。前導碼還包含柱面與扇區號以及某些其他信息。數據部份的大小是由低級格式化程式決定的，大多數磁盤是使用512字節的扇區。

ECC域包含冗餘訊息，可以用來恢復讀錯誤。該域的大小和內容隨生產商的不同而不同，它取決於設計者為了更高的可靠性願意放棄多常磁盤空間以及控制器能夠處理的ECC編碼有多複雜。16字節的ECC域並不是罕見的。

所有硬碟都分配有某些數目的備用扇區，用來取代具有制造瑕疵的扇區。

柱面斜進（cylinder skew)：每個磁道上第0個扇區的位置與前一個磁道存在偏移。因為每個磁道周長不一樣，所以偏移量需要考慮幾合的形狀。

低級格式化會使磁盤的容量減少，減少的量取決於前導碼、扇區間間隙和ECC的大小以及保留的備用扇區的數目。通常格式化的容量比未格式化的容量低20%。備用扇區不計入格式化的容量，所以一種給定類型的所有磁盤在出廠時具有完全相同的容量，與它們實際具有多少扇區無關。

**分區**：在低級格式化之後，需要對磁盤進行分區。在邏輯上，每個分區就像是一個獨立的磁盤。分區對於實現多個操作系統共存是必需的。

某些分區用來交換。

0扇區包含**主引導記錄（MBR）**，它包含某些引導代碼以及處在扇區末尾的分區表。最大支持2TB。具有四個分區的空間。

**GPT(GUID Partition Table）**：可支持最高9.4ZB（9 444 732 965 739 290 426 880字節）

在準備一個磁盤以便於使用的最後一步是對每一個分區進行一次**高級格式化**。這一操作設置一個引導塊、空閒存儲管理（空閒列表或位圖）、根目錄和一個空文件系統。並將一個代碼設置在分區表頂中，以表明在分區中使用的是哪個文件系統。這時系統就可以引導了。

電源打開時，BIOS最先運行，它讀入主引導記錄並跳轉到主引導記錄。然後檢查哪一個分區是活動的，引導扇區包含一個小的程式，它一般會裝入一個較大的引導程式裝載器，該引導程式裝載器將搜索文件系統以找到操作系統內核。該程式被裝入記憶體並執行。

### 5.4.3 磁盤臂調度算法

考慮一個讀或寫磁盤塊需要多長時間，由三個因素決定：

1）尋道時間：將磁盤臂移動到適當的柱面上所需的時間

2）旋轉延遲：等待適當扇區旋轉到磁頭下所需的時間

3）實際數據傳輸時間

尋道時間是最大瓶頸

如果採用**先來先服務**很難優化尋道時間。

許多進程會產生請求，形成一個由硬碟驅動程式維護著的表，按柱面號索引，每一柱面未完成的請求組成一個鏈表，鏈表頭存放在表的相應表目中。

**最短尋道優先（Shortest Seek First, SSF）**：不依照進入隊列順序來尋道，而是先計算在一個固定期間中，一個柱面組中，下一個柱面最近的柱面優先讀取。

這個算法的問題在於如果硬碟負載過大，磁盤臂將會延後訪問某些較邊緣的柱面。

這使得獲得最小響應時間的目標和公平性之間存在著沖突。

**電梯算法**：軟體維護一個二進制位，即當前方向位：UP(向上）或是DOWN（向下）。當一個請求處理完之後，磁盤或電梯的驅動程式檢查該位，如果是UP，磁盤臂移至下一個更高的未完成的請求。如果更高位沒有未完成的請求，則方向位取反。如果不存在未決的請求，那麼磁盤臂則停止並等待。

對於現代硬盤，尋道和旋轉延遲對效能影響甚巨，所以硬碟控制器總是讀出多個扇區並對其進行高速緩存，即使只請求一個扇區時也是如此。一般來說，讀一個扇區的任何請求將導致該扇區和當並磁道的多個或者所有剩餘的扇區被讀出，讀出的扇區取決於控制器的高速緩存中有多少可用的空間。

硬碟的高速緩存是獨立於操作系統的高速緩存。控制器的高速緩存通常保存還沒有被實際請求的塊，但這對於讀操作是很便利的，因為它們只是作為某些其他讀操作的附帶效應而恰巧要在磁頭下通過。

當一個控制器上有多個驅動器時，操作系統應該為每個驅動器都單獨維護一個未完成的請求表。一旦任何一個驅動器空閒下來，就應該發出一個尋道請求將磁盤臂移到下一個將被請求的柱面處（假設控制器允許重疊尋道）。

### 5.4.4 錯誤處理

處理壞塊有兩種方式：

一、在控制器中對它們進行處理：在硬碟出廠前進行測試，並且將一個壞扇區列表寫在磁盤上。對於每一個壞扇區，用一個備用扇區替換它。替換的方法有兩種，一是用備用扇區重新映射為壞塊扇區，二是將壞塊跳過。

在驅動器安裝後，工作期間也會出現錯誤。在遇到ECC不能處理的錯誤時，第一道防線只是試圖再次讀。某些讀錯誤是瞬時性的，也就是由磁頭下的灰塵導致的，在第二次嘗試時錯誤就消失了。

如果控制器注意到某個扇區遇到重複性的錯誤，那麼可以在該扇區完全失效前切換到一個備用扇區。通常是使用壞塊跳過的方法。

二、在操作系統中對它們進行處理：操作系統處理壞壞的方式跟控制器一樣。但如果由操作系統重映射，必須確保壞扇區不出現在任何文件中，並且不出現在空閒列表或位圖中。創建一個包含所有壞扇區的秘密文件，用戶就不會讀到壞塊。

在備份時，為了不讓壞塊文件也被備份，操作系統需要將他隱藏好。

機械故障也是錯誤來源，可能導致磁盤臂中的尋道錯誤。糾正這種錯誤最好是用recalibrate(重新校準)命令，讓磁盤臂盡可能的向最外面移動，並將控制器內部的當前柱面重置為0 。

### 5.4.5 穩定存儲器

一個磁盤子系統具有特性：當一個命令給他時，磁盤要麼正確的寫數據，要麼什麼也不做，讓現有的數據完整無缺的留下。目標是務必確保磁盤的一致性。

模型：

* 假設一個塊執行寫操作時，要嘛正確，要嘛錯誤，並可以通過ECC域的值檢測出來錯誤。
* 假設一個被正確寫入的扇區可能會自發地變壞且變得不可讀，但這個會在一個合理的時間間隔內。
* 假設CPU可能出故障，如此一來，只能停機。出現故障的同時，磁盤寫操作也會停止，導致不正確的數據寫在一個扇區中且可能也有不正確的ECC。

穩定存儲器使用一對完全相同的硬碟，對應的塊一同工作以形成一個無差錯的塊。當不存在錯誤時，在兩個驅動器上對應的塊是相同的，讀取任意一個都能得到相同結果。

設計了以下的操作來達到這個目地：

1）**穩定寫（stable write）**：穩定寫首先將塊寫到驅動器1上，然後將其讀回以校瞼寫的是正確的。如果寫的不正確，就再次做寫和重讀操作，一直到n次，直到正常為止。經田n次連續的失敗後，就將該塊重映射到一個備用塊上，並重複寫和重讀操作直到成功為止，無論要嘗試多少個備用塊。在對驅動器2上對應的塊進行寫和重讀，如果需要的話就重複這樣的操作，直到最後成功為止。如果不存在CPU崩潰，當穩定寫完成後，塊就正確地被寫到兩個驅動器上，並得到兩個校驗。

2）**穩定讀（stable read）**：穩定讀首先從驅動器1上讀取塊。如果這一操作產生錯誤的ECC，則再次嘗試讀操作，一直到n次。如果這些操作都給出錯誤的ECC，則從驅動器2上讀取對應的數據塊。給定一個成功的穩定寫為數據塊留下兩個可靠的副本這樣的事實，且假設在合理的時間間隔內相同的塊在兩個驅動器上自發地變壞的概率可以忽略不計，那麼穩定讀就總是成功的，

3）**崩潰恢復（crasg recovery）**：崩潰後，恢復程式掃描兩個硬碟，比較對應的塊。如果兩塊都是好的就什麼都不做。如果其中一個具有ECC錯誤，那麼壞塊就用對應的好塊來覆蓋。如果一對塊都是好的但是不相同，那麼就將驅動器1上的塊寫到驅動器2上。

如果存在CPU崩潰，則分成五種情況：

1. 崩潰在寫兩個塊之前。恢復的時候，什麼都不用修改而舊的值將繼續存在。
2. 崩潰在寫驅動器1期間，破壞了該塊的內容。恢復程式透過驅動器2上的塊來恢復。
3. 崩潰在寫完驅動器1，但還沒寫驅體器2之前。恢復程式將塊從驅動器1複制到驅動器2上。
4. 崩潰在寫剛驅動器1，在寫驅動器2的期間。解法同2
5. 崩潰發生在寫完之兩個塊之後。不用修復。

## 5.5 時鐘

又稱為定時器（timer）。

時鐘負責維護時間，並防止一個進程壟斷CPU，還有其他功能。

### 5.5.1 時鐘硬體

由**晶體振蕩器**、**計數器**、**存儲寄存器**組成。

晶體振蕩器：由石英晶體適當的切割並安裝在一定的電壓之下時，可以產生非常精準的周期性信號，一般來說，頻率範圍是幾百兆赫茲。它給計算機的各種電路提供同步信號，該信號被發送到計數器，使其遞減計數至0。當計數器變為0時，產生一個CPU中斷。

可編程時鐘的優點是其中斷頻率可以由軟體控制。如果採用500MHz的晶體，那麼計數器將每隔2ns脈動一次。對於（無符號）32位寄存器，中斷可以被編程為從2ns時間間隔發生一次到8.6s時間間隔發生一次。可編程時鐘芯片通常包含兩個或三個獨立的可編程時鐘，並還具有許多其他選頂（例如，用正計時代替倒計時、屏蔽中斷等。

為了防止計算機的電源被切斷時丟失當前時間，大多數計算機具有一個由電池供電的備份時鐘，是由在數字手表中使用的那種類型的低功耗電路實現的。

UNIX的時間原點是：1970年1月1日

WINDOWS是：1980年1月1日

每次一次時鐘滴答都使實際時間增加一個計數。通常會提供實用程式來手工設置系統時間和備份時鐘，並使兩個時鐘保持同步。

### 5.5.2 時鐘軟體

功能：

1）維護日時間：使用32位的計數器很難維護超過兩年的時間。有三種方法解決：

​	一、使用64位的計數器

​	二、以秒為單位維護日時間，而不是以時鐘滴答為單位。需要有一個輔助計數器來對時鐘滴答計數，直到累計至完整的一秒。

​	三、對時鐘滴答計數，這是是相對於系統引導的時間，而不是相對於一個固定的外部時間。

2）防止進程超時運行：啟動一個進程時，調度程式就將一個計數器初始化為以時鐘滴答為單位的該進程時間片的取值。每次時鐘驅動程式將時間片計數器減1。當計數器變為0時，時鐘驅動程式調用調度程式以啟動另一個進程。

3）對CPU的使用情況記帳：每當一個進程啟動時，便啟動一個不同於主系統定時器的輔助定時器。當進程終止時，讀出這個定時器的值就可以知道該進程運行了多長時間。為了正確記帳，當中斷發生時應將輔助定時器保存起來，中斷結束後再將其恢復。

4）處理用戶進程提出的alarm系統調用：報警通常是信號、中斷、消息、或者類似的東西。需要此類報警的應用是網路，用來確定一個封包是否在一定的時間內響應。

用一個物理時鐘來模擬多個虛擬時鐘，一種方法是維護一張表，將所有未完成的定時器的信號時刻記入表中，還要維護一個變量給出下一個信號的時刻。

使用鏈表把未完成的時鐘請求按時間排序連在一起，比模擬多個時鐘更有效。

每個頂中記錄著下一個信號，經過一個滴答，下一個信號減1，當它變為0時，就引發與鏈表中第一個表頂相對應的信號，並將這一個頂從鏈表中刪除，然後將下一個信號設置為現在處於鏈表頭的頂的取值。

5）為系統本身的各個部分提供監視定時器：用來檢測死機之類的問題。監視定時器可以用來對停止運行的系統進行復位。在系統運行時，它會定期復位定時器，所以定時期永遠不會過期。所以定時器過期代表系統很久沒有運行了，就會導致糾正的行動。

6）完成概要剖析、監視和統計信息收集

### 5.5.3 軟定時器

大多數計算機擁有輔助可編程時鐘，可設置以程式需要的任何速率引發定時器中斷。

該定時器是主系統定時器以外的。

一個300MHz的PentiumII電腦上該中斷經實測要花4.45micro second。

**軟定時器**避免了中斷。無論何時當內核因某種其他原因在運行時，在它返回到用戶態之前，它都要檢查實時時鐘以了解軟定時器是否到期。如果軟定時器到期，則執行被調度的事件，而無需切換到內核態，因為系統已經在內核態。在完成工作後，軟定時器被復位以便再次鬧響。

軟定時器密著因為其他原因進入內核的頻率而脈動，這些原因包括：

1）系統調用

2）TLB未命中

3）頁面故障

4）I/O中斷

5）CPU變成空閒

## 5.6 用戶界面：鍵盤、滑鼠和螢幕

終端：包含一個鍵盤、螢幕的一個工作單位

### 5.6.1 輸入軟體

鍵盤包含一個嵌入式微處理器，該微處理器通過一個特殊的串行端口與主板上的控制芯片通信。每當鍵盤按下一個鍵都會產生一個中斷，被按鍵被釋放時會產生第二個中斷。每當發生鍵盤中斷時，鍵盤驅動程式都要從與鍵盤相關聯的I/O端口提取信息，以了解發生什麼事情。

#### 1. 鍵盤軟體

I/O端口中的數字是鍵的編號，稱為**掃描碼（scan code）**，而不是ACSII碼。鍵盤的鍵不超過128個，所以只需要7個位表示鍵的編號。當鍵按下時，第8位設置為0 ，當鍵釋放時，第8個位設置為1。跟踪每個鍵的狀態是驅動程式的任務，所以硬體做的工作是給出鍵被按下和釋放的中斷，其他事情由軟體來做。

echoing：用戶輸入後可以在螢幕上看到他的輸入。

規範模式垂，特殊字符所代表的意義：

| 字符   | POSIX名 | 注釋                     |
| ------ | ------- | ------------------------ |
| CTRL-H | ERASE   | 退格一個字符             |
| CTRL-U | KILL    | 擦除正在鍵入的整行       |
| CTRL-V | LNEXT   | 按字面意義解釋下一個字符 |
| CTRL-S | STOP    | 停止輸出                 |
| CTRL-Q | START   | 開始輸出                 |
| DEL    | INTR    | 中斷進程（SIGINT)        |
| CTRL-\ | QUIT    | 強制核心轉儲（SIGQUIT）  |
| CTRL-D | EOF     | 文件結尾                 |
| CTRL-M | CR      | 回車                     |
| CTRL-J | NL      | 換行                     |

#### 滑鼠軟體

### 5.6.2 輸出軟體

#### 1. 文本窗口

一個字符塊或者是一行是在一個系統調用中被寫到窗口上的

屏幕編輯器和許多其他複雜的程式需要能夠以更加複雜的方式更新屏幕，例如在屏幕的中間替換一行。為滿足這樣的需要，大多數輸出驅動程式支持一系列命令來移動光標，在光標處插入或者刪除字符或行，這些命令常常被稱為轉義序列（escape sequence）。

一種解決方案是termcap的終端數據庫。定義了許多基本動作，例如將光標移動到（行，列）。將轉義序列轉換成將要被執行寫操作的終端的實際轉義序列。

 轉義序列的標準化

#### 2. X窗口系統

幾乎所有UNIX系統的用戶界面都以 X窗口系統為基礎，簡稱X。

當X在一台機器垂運行時，從鍵盤或滑鼠採集輸入並將輸出寫到屏幕上的軟體稱為**X伺服器**。它必須跟踪當前選擇了哪些窗口（鼠標指針所在處），這樣它就知道將路的鍵盤輸入發送給哪個客戶，稱為X客戶的運行中的程式進行通信。它將鍵盤與鼠標輸入發送給X客戶，並從X客戶接收顯示命令。

X伺服器總是位於用戶的電腦內部，而X客戶有可能在遠方的遠程伺服器上。X服務主要工作是在屏幕上顯示位，所以讓它靠近用戶是有道理的。

X不是一個完全的GUI，需要運其他軟體層。一層是Xlib，它是一組庫過程，用於訪問X的功能。這些過程形成了X窗口系統的基礎。

為了使X的編程更容易，作為X的一部分提供了一個工具包，組成了Intrinsics（本征函數集）。這一層管理按鈕、滾動條以及其他稱為**窗口小部件（widget）**的GUI元素。

要使GUI有一致的外觀與感覺，還需要另外一層軟體（或者幾層軟體）。一個例子是**Motif**，這是Solaris和其他商業UNIX系統上使用的公共桌面環境(Common Desktop Environment)的基礎。大多數應用程式調用Motif而不是Xlib。

![image-20200810110102678](/home/jackyfeng/GoogleDrive/電子書/學習筆記/os-graph5-33.jpg)

窗口管理器（windows manager)：是一個控制屏幕上窗口創建、刪除以及移動的進程。負責發送命令到X伺服器告訴他做什麼。經常運行在與X客戶相同的機器上。

X使用的四種消息傳遞：

1）從程式到工作站的繪圖命令

2）工作站對程式請求的應答

3）鍵盤、鼠標以及瘉他事件的通告

4）錯誤消息

從程式到工作站的大多數繪圖命令是作為單向消息發送的，不期望應答，如此將不會因為等待應答而阻塞進程，降低了效能。但當程式需要來自工作站的信息時，它只能等待直到應答返回。

X是事件驅動的，事件排成隊列，程式從隊列中讀取事件。

X中的資源是一個保存一定信息的數據結構。應用程式在工作站上創建資源。資源可以有進程間共享。資源的存活期很短，當工作站重新啟動後資源不會繼續存在。資源包括：窗口、字體、顏色映射（調色板）、像素映射（位圖）、光標以及圖形上下文。圖形上下文用於將屬性與窗回關聯起來。

X程式的框架包含某些頭文件開始，並聲明某些變量。然後，它與X伺服器連接，X伺服器是作為XOpenDisplay的參數設定的。接著，它分配一個窗口資源並且將資源的句柄存放在win中。

```c
#include <X11/Xlib.h>
#include <X11/Xutil.h>

main(int argc, char *argv[])
{
    Display disp;               /*伺服器標識符*/
    Window win;                 /*窗口標識符*/
    GC gc;                      /*圖形上下文標識符*/
    XEvent event;               /*用於存儲一個事件*/
    int running = 1;
    
    disp = XOpenDisplay("display_name");    /*連接到X伺服器*/
    win = XCreateSimpleWindow(disp, ...);    /*為新窗口分配記憶體*/
    XSetStandardProperties(disp,...);        /*向窗口管理器宣布窗口*/
    gc = XCreateGC(disp, win, 0, 0);         /*創建圖形上下文*/
    XSelectInput(disp, win, ButtonPressMask|KeyPressMask|ExposureMask);
    XMapRaised(disp, win);                   /*顯示窗口；發送Expose事件*/
    
    while (running){
        XNextEvent(disp, &event);             /*獲得下一個事件*/
        switch (event.type){
            case Expose:         ...;  break; /*重繪窗口*/
            case ButtonPress:    ...;  break; /*處理鼠標點擊*/
            case KeyPress:       ...;  break; /*處理鍵盤輸入*/
        }
    }
	XFreeGC(disp, gc);                        /*釋放圖形上下文*/
    XDestroyWindow(disp, win);                /*回收窗口的記憶體空間*/
    XCloseDisplay(disp);                      /*拆卸網路連接*/
}
```

#### 3. 圖形用戶界面

WIMP：窗口（Window）、圖標（icon）、選單（Menu）、定點設備（Pointing device）

GUI可以在用戶級別(UNIX)或是操作系統（windows）中實現。

GUI的輸出輸入仍然使用鍵盤和鼠標，但是輸出幾乎總是送往特殊的硬體電路板，稱為**圖形適配器（graphic adpator)**。圖形適配器包含特殊的記憶體，稱為影像RAM（video RAM），它保存出現在螢幕上的圖像。通常具有強大的32位或64位CPU和多達1GB自己的RAM，獨立於電腦機主存。

常見的尺寸（水平×垂直像素）：1280×960、1600×1200、1920×1080、2560×1600和3840×2160。也就是4：3。

假設解析度為1920×1080（全高清視頻的尺寸），每個像素具有24位的色彩，光是保存圖像就需要大約6.5MB的RAM。

所以擁有更多的RAM就可以一次保存許多圖像。如果整個螢幕每秒刷新75次，那麼影像RAM必須能夠連續的以每秒445MB的速率發送數據。

#### 4. 位圖（bitmap）

通過在圖像上覆蓋一層網格掃描輸入。每一個網格方塊的平均紅、綠、藍取值被採樣並保存為一個像素的值。

位圖也用來處理文本。在某種字體中表示一個特殊字符的一種方法就是將其表示為小的位圖。

調用BitBlt過程來使用位圖

`BitBlt(dsthdc, dx, dy, wid,ht, srchdc, sx, sy, rasterop)`

BitBlt還可以執行布爾運算的可能，從而可以將源位圖與目標位圖合併在一起。也可以執行異或運算。

位圖的問題在於凝能縮放。8×12方框內的一個字符在640×480的螢幕上看起來是適當的。但該位圖以每英寸1200 點複制到10200位×13200位的列印頁面上，那麼字符寬度（8像素）。

windows還支援一種DIB（Device Independent Bitmap，設備無關的位圖）的數據結構。擴展名為.bmp

#### 5. 字體

使用TrueType

## 5.7 瘦客戶機

大多數用戶想要高性能的交互式計算，但是實在不想管理一台電腦。這一結論導致研究人員重新研究了分時系統使用的瘦客戶機，它們符合現代終端的期望。X是這一方向的一個步驟並專用的X終端一度十分流行。

最著名的瘦客戶機是Chromebook，雖然它是由Google推進的，但是大大小小的制造商們提供了各種的型號。該筆記本運行CromeOS，基於Linux和Chrome Web瀏覽器，並假設永久在線。

## 5.8 電源管理

桌面PC通常具有200瓦的電源（其效率一般是85%，15%進來的能量損失為熱量）。如果全世界1億台這樣的機器同時開機，合起來它們要用掉20000兆瓦的電力。這是20 座中等規模的核電站的總產出。

另一個需要考量的就是電池供電的設備，包括筆記本型電腦、掌上機及Web便籤簿。

### 5.8.1 硬體問題

電池分為一次性及重複性。

鋰電池是現在的主流，不用完全耗盡就可以充電。

電池節約使用的措施是：CPU、記憶體以及I/O設備設計具有多種狀態：工作、睡眠、休眠、關閉。

* 哪些設備能夠被控制
* 它們是工作還是關閉的
* 在低功耗狀態下節省了多少電能
* 重啟設備耗能嗎
* 進入低功耗狀態時是不是必須保存某些上下文
* 返回到全功耗狀態要花費多長時間