# 第二章 進程與線程

從本章開始我們將深入考察系統是如何設計和構造的。操作系統中最核心的概念是進程: 這是對正在運行程序的一個抽象。操作系統的其他所有內容都是圍繞著進程的概念展開的，所以，讓操作系統的設計者盡早並透徹地理解進程是非常重要的。

進程是操作系統提供的最古老的也是最重的抽象概念之一。即使可以利用的cpu 只有一個，但它們也支持並發操作的能力。它們將一個單獨的cpu 變成多個虛擬的cpu。沒有進程的抽象，現代計算將不復存在。在本章裡我們會通過大量的緣節去探究進程滿以及它們的第一個親戚-線程

## 2.1 進程

所有現代的計算機經常會在同一時間做許多事。習慣於在個人計算機上工作的人們也許不會十分注意這個事實，因此列舉一些例子可以更清楚地說明這一問題。先考慮一個網路伺服器。從各處進入一些網頁請求。當一個請求進入時，伺服器檢查是否其需要的網頁在緩存中。如果是滿則把網頁發送回去，如果不是，則啟動一個磁盤請求以獲取網頁。然而，從cpu的角度來看，磁盤請求需要漫長的時間。當等待磁盤請求完成時，其他更多的請求將會進入。如果有多個磁盤存在，會在滿足第一個請求之前就二連三地對其他的磁盤發出一些或所有的請求。很明顯，需要一些方法去模擬並控制這種併發。進程(特別是線程)在這裡就可以產生作用。

現在考慮只有一個用戶的pc。一般用戶不知道，當啟動系統時，會秘密啟動進程。例如，啟動一個進程用來等待進入的電子郵件; 或者啟動另一個防毒進程周期性地檢查是否有新的有效病毒定義。另外，某個用戶進程也許會在所有用戶上網的時候打印文件以及燒錄Cd-rom。所有的這些活動需要管理，于是易個支持多進程的多道程序系統在這裡就顯得很有用了。

在任何多道程序設計系統中，cpu由一個進程快速切換至另一個進程，使每個進程各運行幾十或幾百個毫秒。嚴格地說，在某一個瞬間，cpu 只能運行一個進程。但在1 秒鐘期間，它可能運行多個進程，這樣就產生併類的錯覺。有時人們所說的偽併行就是指這種情形，以此來區分多處理器系統(該系統有兩個或多個cpu共享同一個物理內存)的真正硬件併行。人們很難對多個併行活動進行跟踪。因此，經多年的努力，操作系統的設計者發展了用以描述併行的一種概念模型(順序進程)，使得併行更容易處理。有關該模型、它的使用以及它的影響正是本章的主題

### 2.1.1 進程模型

在進程模型中，計算機上所有可運行的軟體，通常也包括操作系統，被組織成若干`順序進程`，簡稱進程。

一個進程就是一個正在執行程序的實例，包括程序計數器、寄存器和變量的當前值。

從概念上說，每個進程擁有它自已的虛擬cpu。當然，實際上真正的cpi 在各進程之間來回切換。但為了理解這種系統，考慮在(偽)併行情況下運行的進程集，要比我們試圖跟踪cpu如何在程序間來回切換簡單得多。正如在第一章所看到的，這種快速的切換稱作`多道程序設計`。

在圖2-1a中我們看到，在一台多道程序計算機的內存中有4 道程序。在圖2-1b中，這4 道程序被抽象為4個各自擁有自己控制流程(即每個程序自己的邏輯程序計數器)的進程，並且每個程序都獨立地運的程序計數器中。當該程序結束(或暫停執行)時，物理程序計數器被保存在內存中該進程的邏輯程序計數器中。在圖2-1中我們看到，在觀察足夠的一段時間後，所有的進程都運行了，但在任何一個給定的瞬間僅有一個進程真正在運行。

在本章，我們假設只有一個cpu，然而，逐漸這個假設就不為真了，因為新的蕊片經常是多核的，包含2個、4個或更多的cpu。我們將會在第8 章介紹多核蕊片以及多處理器，但是在現在，一次只考慮一個cpu會更簡單一些。因此，當我們說一個cpu只能真正一次運行一個進程的時候，即使有２　個核（或ＣＰＵ），每一個核也只能一次運行一個進程

由以ＣＰＵ在各進程之間來回快速切換，所以每個進程執行其運算的速度是不確定的。而且當同一進程再次運行時，其運算速度通常也不可再現。所以，在對進程編程時決不對時序做任何確定的假設。例如，考慮一個Ｉ／Ｏ進程，它用流式磁帶機恢復備份的文件，它執行一個１００００次的空循環以等待磁帶機進程可能在第一條記錄通過磁頭之還未被再次運行。當一個進程具有此類嚴格的實時要求時，也就是一些特定事件一定要在妡指定的若干毫秒內發生，那麼必須採取特殊措施以保證它們一定在這段時間中發生。然而，通常大多數進程並不受cpu 多道程序設計或其他進程相對速度的影響。

進程和程序間的區別是很微妙的，但非常重要。用一個比喻可以使我們更容易理解這一點。想象一位有一手廚藝的計算機科學家正在為他的女兒烘製生日蛋糕。他有做生日蛋糕的食譜，廚房裡有所需的原料: 麵粉、雞蛋、糖、香草汁等。在這個比喻中滿做蛋糕的食譜就是程序(即用適當形式描述的算法)，計算機科學家就是處理器(cpu)，而做蛋糕的各種原料就是輸入數據。進程就是廚師閱讀食譜、 取來各種原料以及烘製蛋糕等一系列動作的總和。

現在假設計算機科學家的兒子哭著跑了進來，說他的頭被一只蜜蜂螫了。計算機科學家就記錄下他照著食譜做到哪兒了(保存進程的當前狀態)，然後拿出一本急救手冊，按照其中的指示處理螫傷。這裡，我們看處理機從一個進程(做蛋糕)切換到另一個高優先級的進程(實施醫療救治)，每個進程擁有各自的程序(食譜和急救手冊)。當蜜蜂螫傷處理完之後，這位計算機科學家又回來蛋糕，從他離開時的那一步繼續做下去。

這裡的關鍵思想是: 一個進程是某種類型的一個活動，它有程序、輸入、輸出以及狀態。單個處理器可以被若干進程共享，它使用某種調度算法決定何時停止一個進程的工作，並轉而為另一個進程提供服務。

值得注意的是，如果一個程序運行了兩遍，則算作兩個進程。例如，我們可能經常兩次啟動同一個字處理軟體，或在有兩個可用的打印機的情況下同時打印兩個文件。像"兩個進程恰好運行同一個程序"這樣的事實其實無關緊要，因為它們是不同的進程。操作系統能夠使它們共享代碼，因此只有一個副本放在內存中，但那只是一個技術性的細節，不會改變有兩個進程正在運行的概念。

### 2.1.2 創建進程

操作系統需要有一種方式來創建進程。一些非常簡單的系統，即那種只為運行一個應用程式設計的系統(例如，微波爐中的控制器)，可能在系統啟動之時，以後所需要的所有進程都已存在。然而在通用系統中，需要有某種方法在運行時按需要創建或撤銷進程。我們現在開始考察這個問題。

有4種主要事件導致進程的創建:

1) 系統初始化

2) 執行了正在運行的進程所調用的進程創建系統調用

3)用戶請求創建一個新進程。

4) 一個批處理作業的初始化

啟動操作系統時，通常會創建若干個進程。其中有些是前台進程，也就是同用戶(人類)交互並且替他們完成工作的那些進程。其他的是後台進程，這些進程與特定的用戶沒有關係，相反，卻具有某些專門的功能。例如，設計一個後台進程來接收發來的電子郵件，這個進程在一天的大部份時間都在睡眠，但是當電子郵件到達時就突然被喚醒了。也可以設計另一個後台進程來接收對該機器中web頁面的訪問請求，在請求到達時喚醒該進程以便服務該請求。停留在後台處理諸如電子郵件、web 頁面、新聞、打酪之類活動的進程稱為守護進程。在大型系統中通常有很多守護進程。在unix中，可以用ps程序列出正在運行的進程; 在windows中，可使用任務管理器。

除了在啟動階段創建進程之外，新的進程六可以以後創建。易○正在運行的進程經常發出系統調用，以便創建一個或多個新進程協助其工作。在所要從事的工作可以容易地劃分成若干相關的但沒有相互作用進程時，創建新的進程就特別有效果。例如，如果有大量的數據要通過網路調取並進行順序處理，那麼創建一個進程取數據，並把數據放入共享緩沖區中，而讓第二個進程取走數據項並處理之，應該比較容易。在多處理機中，讓每個進程在不同的cpu上運行會使整個作業運行得更快。

在交互式系統中，鍵入一個命令或者點(雙)擊一個圖標就可以啟動一個程序。這兩個動作差的任何一個都會開始一個新的進程，並在其中運行所選的程序。在基于命令行的unix系統中運行的程序x，新的進程會從該進程接管開啟它的窗口。在microsofr windows中，多數情形都是這樣的，在一個進程開始時滿忙並沒有窗口，但是它可以創建一個窗口。在unix 和windowns系統中，用戶可以同時打多個窗口，每個窗口都運行一個進程。通過鼠標用戶可以選擇一個窗口並且與該進程交互，例如，在需要時提供輸入。

最後一種創建進程的情形僅在大型機的批處理系統中應用。用戶在這種系統中(可能是遠程地)提交批處理作業。在操作系統認為有資源可運行另一個作業時，它創建一個路的進程，並運行其輸入隊列中的一個作業。

從技術上看，在所有這些情形中，新進程都是由於一個已存在的進程執行了一個用於創建進程的系統調用而創建的。這個進程可以是一個運行的用戶進程、一個由鍵盤或鼠標啟動的系統進程或者一個批處理管理進程。這個進程所做的工作是，執行一個用來創建新進程的系統調用。這個系統調用通知操作系統創建一個新進程，並且直接或間接地指定在該進程中運行的程序。

在UNIX系統中，只有`fork`可以用來創建新進程。這個系統調用會創建一個與調用進程相同的副本。在調用了fork後，這兩個進程(父進程和子進程)擁有相同的存儲映像、同樣的環境字符串和同樣的打開文件。通常，子進程接著執行execve或一個類似的系統調用，以修改其存儲映像並運行一個新的程序。

父進程和子進程有各自不同的地址空間。如果其中某個進程在其地址空間中修改了一個字，這個修改對其他進程而言是不可見的。在UNIX中，子進程的初始地址是父進程的一個副本，但是這裡涉及兩個不同的地址空間，不可寫的記憶體區是共享的

### 2.1.3 進程的終止

進程的終止由下列條件引起:

##### 1) 正常退出(自願的):

多數進程因為完成了工作而終止。當編譯器完成了所給定程序的編譯之後，編譯器執行一個系統調用(unix調用exit，windows調用ExitProcess)，來通知操作系統它的工作已經完成。

##### 2)出錯退出(自願的):

給錯參數、編譯時，文件不存在，都會導致錯誤退出。

##### 3)嚴重錯誤(非自願):

執行非法指令、引用不存在的記憶體，或除數是零。這類錯誤中，進程是收到中斷信號而中止。

##### 4)被其他進程殺死(非自願)

kill 或是windows中的TerminateProcess

### 2.1.4 進程的層次結構

某些系統中，當進程創建了另一個進程後，父進程和法進程就以某種形式繼續保持關聯。子進程自身可以創建更多的進程，組成一個進程的層次結構。請注意，這與植物和動物的有性繁殖不同，進程只有一個父進程(但是可以有零個、一個、兩個、或多個子進程)

在UNIX中，進程和它的所有子女以及後裔共同組成一個進程組。當用戶從鍵盤發出一個信號時，該信號被送給當前與鍵鑑相關的進程組中的所有成員(它們通常是在當前窗口創建的所有活動進程)。每個進程可以分別捕獲該信號，忽略該信號或采取默認的動作，即被該信號殺死。

### 2.1.5 進程的狀態

一個進程的輸出結果可能作為另一個進程的輸入，例如: `cat chapter1 chapter2 chapter3 | grep tree`

當grep準備就緒但cat的輸入還沒執行完成並輸入給grep時，grep就會先阻塞。

一個進程在邏輯上不能運行時，它就會阻塞。可能的原因有:

1. ​	等待可以使用的輸入
2. ​	因為操作系統調度另一個進程占用了CPU，但概念上是能夠運行的，只是被迫停止。
3. ​	系統技術上的原因引起的阻塞(由於沒有足夠的CPU，所以不能使每個進程都有一台它私用的處理器)

進程運行的三種狀態:

1) 運行態: 該時刻進程實際占用CPU

2) 就緒態: 可運行，但因為其他進程正在運行而暫時停止

3) 阻塞態: 除非某種外部事件發生，否則進程不能運行

這三種狀態有四種關係，

1. ​	因為某種關係無法再運作，可以是pause指令，或是當程序沒有有效的輸入存在。
2. ​	當操作系統決定讓其他進程執行時，發生轉換2
3. ​	當系統已經讓所有其他進程享有了它們應有的公平待遇而重新輪到第一個進程再次占用CPU時間時，發生轉換3。
4. ​	當進程等待的外部事件發生時，發生轉換4。

調度程序就是用來決定應當運行哪個進程、何時運行及應該運行多長時間。

### 2.1.6 進程的實現

#### 進程表

結構是數組，包含

- ​	程序計數器
- ​	堆棧指針
- ​	記憶體分配狀況
- ​	所打開文件的狀態
- ​	帳號和調度信息

中斷向量: 位於記憶體底部的固定區域，是一組中斷服務的入口位址。

中斷發生後操作系統最底層的工作步驟

1. ​	硬體將程序計數器、PSW、一個或多個寄存器等壓入堆棧
2. ​	硬體從中斷向量裝入新的程序計數器
3. ​	匯編語言過程保存寄存器值，並刪除硬體壓入堆棧的信息
4. ​	匯編語言過程設置新的堆棧
5. ​	C中斷服務例程運行(典型地讀和緩沖輸入)
6. ​	調度程序決定下一個將運行的進程
7. ​	C過程返回至匯編代碼
8. ​	匯編語言過程開始運行新的當前進程

### 2.1.7 多道程序設計

提高CPU的利用率。

由概率的角度來看CPU的利用率。

p: 一個進程等待I/O操作的時間與其停留在記憶體中時間的比率

pn : 當記憶體中同時有n個進程時，所有n個進程都在等待I/O的概率

CPU利用率 = 1 - pn

n 稱為degree of multiprogramming

I/O時間比率越高，要提高CPU使用率的n就要越多

假設計算機有512MB記憶體，操作系統占用128MB，每個用戶程序也占用128MB。可允許的用戶程序約為3個，若80%的時間用於I/O等待，則CPU的利用率為1-0.8n，即49%。在增加512MB的記憶體後，可從3道提高到7道，CPU利用率提高到79%。

## 2.2 線程

一般來說，一個進程有一個地址空間和一個控制線程。但也經常存在一個地址空間中併行運行多個控制線程的情形。

### 2.2.1 線程的使用

需要線程的主要原因，是因為在許多應用中同時發生著多種活動。其中某些活動隨著時間的推移會被阻塞。通過將這些應用程序分解成可以准併行運行的多個順序線程，程序設計模型會變得更簡單。

多線程的併行是併行實體共享同一個地址空間和所有可用數據的能力。

第二個需要多線程的理由是，由於線程比進程更輕量級，所以要比進程更容易創建及撤銷。線程比進程快上10~100倍

第三個理由是如果存在著大量的計算和大量的I/O處理，擁有多個線程允許這些活動彼此重疊進行，從而加快應用程序執行的速度。

第四，在多CPU系統中，真正的併行有了實現的可能。

多線程可以使用戶同時在交互介面上操作一個文件，另一個線程在後端處理文件的修改。在此同時用戶仍可以對文件作簡單的查看。我海還可以增日一個線程對文件每隔幾秒保存在磁碟上。

在這裡，使用進程是無法工作的，因為三個線程都需要在同一個文件上進行操作。通過讓三個線程代替三個進程，三個線程共享公共記憶體，於是它們都可以訪問同一個正在編輯的文件。

#### 多線程的工作方式

現在考慮另一個多線程發揮作用的例子: 一個萬維網伺服器。對頁面的請求發給伺服器，而所請求的頁面發回給客戶機。部分頁面相交於其他頁面，有更多的訪問。

一種組織WEB伺服器方式如圖2-8所示。在這裡，一個稱為`分派程序`(dispatch)的線程從網路中讀入工作請求。在檢查請求後，分派線程挑選一個空轉的工作線程(work thread)，提交該請求，通常是在每個線程所配有的某個專門字中寫入一個消息指針。接著分派線程喚醒睡眠的工作線程，將它從阻塞狀態轉為就緒狀態。

在工作線程被喚醒後，它檢查有關的請求是否在web頁面高速緩存之中，這個高速緩存是所有線程都可以訪問的。如果沒有，該線程開始一個從磁盤調入頁面的read操作，並且阻塞直到該磁盤操作完成。當上述線程阻塞在磁盤操作上時，為了完成更多的工作，分派線程可能挑另一個線程運行，也可能把另一個當前就緒的工作線程投入運行。

#### 有限狀態機

這是一種單線程且非阻塞的工作方式。在請求進入後，線程會考察這個請求，如果請求可被高速緩存滿足，就從緩存返回頁面給用戶。如果不能，則啟動一個非阻塞的磁盤操作。

伺服器會表格中記錄當前請求的狀態，然後去處理下一個事件。

下一個事件有可能是:

一個新工作的請求，就開始新工作的請求。

或是磁盤對先前操作的回答，就從表格中取出對應的信息，並處理該回答。回答會以信號或中斷的形式出現。

在這個模式中，每個計算都有一個被保存的狀態，存在一個會發生且使得相關狀態發生改變的事件集合。

### 2.2.2 經典的線程模型

進程模型基於兩種獨立的概念

- ​	資源分組處理
- ​	執行

#### 線程的第一個模型

用某種方法把相關的資源集中在一起。進程有存放程序正文和數據以及其他資源的地址空間。這些資源包括打開的文件、子進程、即將發生的報警、信號處理程序、帳號信息，都放到進程中可以更容易管理。

多個進程共享物理記憶體、磁盤、印表機和其他資源。

每一個進程有自己的地址空間和單個控制線程。

#### 線程的第二個模型

進程擁有一個執行的線程，通常簡寫為線程。

在線程中有一個程序計數器，用來記錄接著要執行哪一條指令。線程擁有寄存器，來保存線程當前的工作變量。線程還擁有一個堆棧，用來記錄執行歷史，其中每一幀保存了一個已調用的但是還沒有從中返回的過程。

多個線程可運行在同一個進程中。多個線程運行在同一個地址空間中。

由於線程有一樣的地址空間、共享同樣的全局變量。，所以各個線程都可以訪問進程地址空間中的每一個記憶體地址，進程之間是沒有保護的原因是1) 不可能，2)沒有必要

和傳統進程一樣，線程可以處於若干種狀態的任何一個: 運行、阻塞、就緒或終止。

每個線程有自己的堆棧，如圖2-13。每個線程的堆棧有一幀，供各個被調用但是還沒有從中返回的過程使用。在該幀中存放了相應程的局部變量以及過程調用完成之後使用的返回地址。通常每個線程會調用不同的過程，從而有一個各自不同的執行歷史。

線程可能是有層次或無層次的

#### 線程的創建

可以透過thread_create的庫函數來創建新線程。創建線程通常都返回一個線程標識符，這個標識符就是新線程的名字。

#### 線程的退出

當線程完成一個工作後，調用thread_exit庫函數來退出。

也可以使用thread_join等待一個特定的線程退出。這個過程阻塞調用線程直到那個特定線程退出。

#### 線程的yield

使用thread_yield讓線程自動放棄CPU而讓另一個線程運行。

### 2.2.3 POSIX線程

一些Pthread的函數調用

| **線程調用**         | **描述**                       |
| -------------------- | ------------------------------ |
| Pthread_create       | 創建一個新線程                 |
| Pthread_exit         | 結束調用的線程                 |
| Pthread_join         | 等待一個特定的線程退出         |
| Pthread_yield        | 釋放CPU來運行另外一個線程      |
| Pthread_attr_init    | 創建並初始化一個線程的屬性結構 |
| Pthread_attr_destroy | 刪除一個線程的屬性結構         |

Pthread_create創建線程後返回程線程標識符，線程標識符有著PID的作用。

### 2.2.4 在用戶空間中實現線程

把個線程包放在用戶空間中，內核對線程包一無所知。從內核角度考慮，就是按正常的方式管理，即單線程進程。

優點:

- ​	可以在進程不支援線程的操作系統實現。
- ​	每個進程可以有自己的線程調度算法。
- ​	有較好的擴展性。

這個實現會有一個`運行時系統`，是一個管理線程的過程的集合。這些過程包括: pthread_create, pthread_exit, pthread_join, pthread_yield，還有其他過程。

每個進程管理自己線程的線程表，線程表記錄各個線程的屬性，如程序計數器、堆棧指針、寄存器和狀態。

當一個線程轉換到就緒狀態或阻塞狀態時，在該線程表中存放重新啟動該線程所需的信息。

線程的阻塞: 調用運行時系統檢查該線程是否必須阻塞。如果是，就保存該線程的寄存器到線程表，並查看線程表中可運行的就緒線程，並把新線程的保存值重新進入機器的寄存器中。只要堆棧指針和程序計數器一被切換，新的線程又自動投入運行。如果機器有一條保存所有寄存器的指令和另一條裝入全部寄存器的指令，那麼整個線程的切換可以在幾條指令完成。這樣的線程切換比陷入內核要快一個數量級。

用戶級線程的關鍵問題在於如何實現阻塞系統調用。首先要允許每個線程使用系統調用，但還要避免被阻塞的線程影響其他的線程。

#### 用戶級線程做系統調用

一種方案是將系統調用改成非阻塞的，但是要改寫許多用戶程序，太費時費力。

另一種是提前通知系統調用的阻塞。某些系統有一個select系統調用。可以允許調用者通知預期的read是否會阻塞。有了這個調用，庫過程read就可以被新的操作替代，首先進行select調用，然後只有在安全的情況下(即不會阻塞)才進行read調用。如果read調用會被阻塞，有關的調用就不進行，代之以運行另一個線程。這個處理方法需要重寫部分系統調用庫，所以效率不高也不優雅。

在系統調用周圍從事檢查的這類代碼稱為包裝器(jacket或wrapper)

### 2.2.5 在內核中實現線程

在這個實現方式中，已經不需要運行時系統了。每個進程中也沒有線程表。

內核中有用來紀錄系統中所有線程的線程表。當某個線程希望創建一個新線程或撤銷一個已有線程時，它進行一個系統調用，這個系統調用通過對線程表的更新完成線程創建或撤銷工作。

內核的線程表保存了每個線程的寄存器、狀態和其他信息。這些信息和在用戶空間中的線程是一樣的，但是現在保存在內核中。

所有能夠阻塞線程的調用都以系統調用的形式實現，這與運行時系統過程相比，代價是相當可觀的。當有一個線程阻塞時，內核根據其選擇，可以運行同一個進程中的另一個線程(若有一個就緒線程)或者運行另一個進程中的線程。

在內核級使用較環保的方式回收線程。當線程被撤銷時，將其標示為不可運行的，不影響其內核數據結構。稍後，在必須創建一個新線程時，就重新啟動某個舊線程，節省了一些開銷。

內核線程不需要任何新的、非阻塞系統調用。

如果某個進程中的線程引起了頁面故障，內核可以很方便的檢查該進程是否有任何其他可運行的線程。如果有，在等待所需要的頁面從磁盤讀入時，就選擇一個可運行的線程運行。

內核線程的問題:

1. ​	當一個多線程進程創建新的進程時，新進程是擁有與原進程相同數量的線程，還是只有一個線程?這取決於下一步要做什麼。如果要調用exec來啟動一個新的程序，就創建一個線程就好。如果它繼續執行，則應該複制所有的線程。
2. ​	信號的接收。信號是發給進程的。多個線程註冊了某些信號會發生什麼事。

### 2.2.6 混合實現

使用內級線程將用戶級線程與某些或者全部內核線程多路復用起來。

內核只識別內核級線程並對其進行調度。其中一些內核級線程會被多個用戶級線程多路復用。

### 2.2.7 調度程序激活機制

調度程序激活(scheduler actication)的目標是模擬內核線程的功能，但是為線程包提供通常在用戶空間中才能實現的更好的性能或者進行提前檢查。

使用調度程序激活機制時，內核給每個進程安排一定數量的虛擬處理器，並且讓(用戶空間)運行時系統將線程分配到處理器上。在多處理器中，虛擬處理器可能成為真實的CPU。

虛擬處理器初始數量為一個，可以申請更多的處理器並且在不用時退回。內核也可以主動取回。

上行調用(upcall): 當內核發現一個線程阻塞後，會通知該進程的運行時系統，在堆棧中以參數形式傳遞有問題的線程編號和所發生事件的描述。內核是通過一個已知的起始地址啟動運行時系統，從而發出了通知。

當發生upcall時，運行時系統就重新調度其線程。它會這樣做: 把當前線程標記為阻塞並從就緒表中出另一個線程，設置其寄存器，然後再啟動之。當內核知道原來的線程又可以運行時(例如，原先讀取的管道有了數據，或已經從磁盤讀入了故障的頁面)，又再次upcall運行時系統，通知他這一事件。此時，運行時系統按照自己的判斷，選擇立即重啟動被阻塞的線程，或把它放入就緒表中稍後運行。

upcall不遵守分層原則，因為n層是不能調用n✛1層中的過程

### 2.2.8 彈出式線程

在分布式系統中處理到來的消息，例如服務請求。

傳統方法是將進程或線程阻塞在一個receive系統調用上，等待消息到來。當消息到達時，該系統調用接收消息，並打開消息檢查其內容，然後進行處理。

彈出式線程: 只有進程收到消息時，才會創建處理消息的線程。

使用彈出式線程之前，需要提前進行計劃。例如，哪個進程中的線程先運行？

### 2.2.9 使單線程代碼多線程化

許多已有的程序是為單線程進程編寫的。把這些程序改寫成多線程需要比直接寫多線程程序更高的技巧。下面我們考察一些其中易犯的錯誤。

先考察代碼，一個線程的代碼就像進程一樣，通常包含多個過程，會有局部變量、全局變量和過程參數。局部變量和參數不會引起任何問題，但是有一個問題是，對線程而言是全局變量，並不是對整個程序也是全局的。有許多變量之所以是全局的，是因為線程中的許多過程都是使用它們，但是其他線程在邏輯上和這些變量無關。

作為一個例子，考慮由unix維護的errno變量。當進程(或線程)進行系統調用失敗時，錯誤碼會放入errno。

作為一個全局變量，線程1將errorno設置以後，跳到線程2執行，但是發生錯誤，於是又變更了errono。這樣導致了線程1的返回值將永遠消失。

一種解決方案是全面禁止全局變量。

另一種是為每個線程賦予私有的全局變量如圖所示。每個線程有自己的errno以及其他全局變量的私有副本。

還有一種就是引入新的庫過程，以便創建、設置和讀取這些線程範圍的全局變量。

## 2.3 進程間通信(Inter Process Communication,IPC)

進程間經常需要進程通信。例如，在一個shell管道中，第一個進程的輸出必須傳送給第二個進程。

需要處理三個問題:

- ​	如何把一個進程的消息傳遞給另一個
- ​	如何確保兩個或更多的進程在關鍵活動中不會出現交叉
- ​	如何確保消息的順序。

### 2.3.1 競爭條件

競爭條件：兩個或多個進程讀寫某些共享數據，而最後的結果取決於進程順序的精確時序。

### 2.3.2 臨界區

避免競爭條件的方法就是找出某種途徑來阻止多個進程同時讀寫共享的數據，也就是互斥(mutual exclusion)，即以某種手段確保一個進程在使用一個共享變量或文件時，其他進程不能做同樣的操作。

另一種方式就是將兩個進程適當的安排，讓它們的臨界區不會重疊。

臨界區就是一個進程使用共享數據的時間片。

對於一個避免競爭條件的解決方案，必須滿足以下四個條件:

1. ​	任何兩個進程不能同時處於其臨界區
2. ​	不應對CPU的速度和數量做任何假設。
3. ​	臨界區外運行的進程不得阻塞其他進程
4. ​	不得使進程無限期等待進入臨界區

### 2.3.3 忙等待的互斥

#### 1. 屏蔽中斷

在單處理器中，最簡單的方法是使每個進程在剛剛進入臨界區後立即屏蔽所有中斷，並在就要離開之前再打開中斷。屏蔽中斷之後CPU將不會被切換到其他進程。於是，一旦某個進程屏蔽中斷後，它就不會被其他進程介入。

在多核心的機器上並沒有用，因為中斷屏蔽只對當前核心有效。

#### 2. 鎖變量

假設有一個共享鎖變量，其初始值為0。當一個進程想進入其臨界區時，它首先測試這把鎖。如果鎖的值為0，則該進程將其設置為1並進入臨界區。若鎖的值為1，則等待到鎖的值變為0。於是，0表示臨界區內沒有進程，1表示已經有某個進程進入臨界區。

也有可能發生同時有兩個進程將鎖設為1的可能，而導致競爭條件

#### 3. 嚴格輪換法

兩個進程使用自旋鎖來避免其他進程干擾運行。自旋鎖是用於忙等待的鎖。忙等待就是一個進程不斷測試是否可進入臨界區的過程。

當一個進程比另一個進程慢很多時，輪流進入臨界區並不是一個好辦法。

#### 4. Peterson解法

在進入臨界區之前，各個進程使用其進程號0或1作為參數來調用enter_region。調用在需要時將使進程等待，直到能安全進入臨界區。在完成對共享變量的操作後，進程將調用leave_region, 表示操作已完成，若其他的進程希望進入臨界區，則現在就可以進入。

圖2-38 中有一件值得注意的事，即某些進程花費了絕大多數時間在計算上，而其他進程則在等待i/o上花費了絕大多數時間。前者稱為計算密集型，後者稱為i/o密集型。典型的計算密集型進程具有較長時間的cpu集中使用和較小頻度的i/o等待。i/o密集型進程有較短時間的cpu 集中使用和頻繁的i/o等待。它是i/o類的，因為這種進程在i/o請求之間較少進行計算，並不是因為它們有特別長的i/o請求。在i/o開始後無論處理數據是多還是少，它們都花費同樣的時間提出硬體請求讀取盤塊。

有必要指出，隨著變得越來越快滿更的進程傾向為i/o密集型。這種現象之所以發生是因為cpu的改進比磁盤的改進快得多，其結果是，未來對i/o密集型進程的調度處理似乎更為重要。這裡的基本思想是，如猹需要運行i/o密集型進程，那麼就應該讓它盡快得到機會，以便發出磁盤請求並保持磁盤始終忙錄。從圖2-6中可以看到，如果進程是i/o密集型的，則需要多運行一些

### 2.3.8 消息傳遞

因為信號量太低級，管程又不是每個程式語言都提供，所以使用消息傳遞來做鎖通知。

這種進程間的通信使用send和receive

send(destination, &message)

receive(source, &message)

#### 1. 消息傳遞系統的設計要點

消息傳遞面臨許多信號量和管程所未涉及的問題和設計難點，特別是位於網路中不同機器上的通信進程情況。例如，消息有可能被網路丟失。為了防止消息丟失，發送方和接收方的協議是：一旦接收信息，接收方馬上回送一自特殊的確認消息。如果一段時間間隔內未收到消息確認，則重發消息。

如果是返回給發送者的確認消息丟失，發送者將重發消息，並且在消息中帶上一段連續的序號。接收者看到如果這個序號跟之前的一樣，表示這個消息之前就收過，可以忽略。

消息系統還需要解決進程命名的問題，在send和receive調用中所指定的進程必須是沒有二義性的。

`身份認證`也是一個問題，該如何讓通信的設備之間信任彼此。

對於發送者和接收者在同一機器上的情況，也存在若干設計問題。性能問題需要透過限制消息大小來解決。

### 2.3.9 屏障

這種同步機制是準備用於進程組而不是雙進程的情形的。

有些應用中劃分了若干階段，並且規定，除非昕有的進程都就緒準備著手下一階段，否則任何進程都不能進入下一個階段。

可以透過`屏障`來實現。當一個進程到達屏障時，它就被屏障阻攔，直到所有進程都到達該屏障為止。

## 2.4 調度

調度程序: 選擇進程進行工作的部份，叫調度系統。調度程序使用調度算法決定程式的選擇方法。

### 2.4.1 調度介紹

在過去，CPU是稀缺資源，所以好的調度算法可以在提高性能和用戶的滿意度方面取得很大的成果。

現在的個人計算機，一個用戶不會在進行文字編輯時，同時在後台編譯一個程式。在用戶向文字處理軟體鍵入一條命令時，調度程序不用做多少工作來判定哪個進程要運行。

又因為現在的電腦運算速度很快。個人電腦受到的限制多數是用戶的輸入速度，而不是CPU處理的速率。

在網路伺服器的情況下，調度就顯得重要多了。因為網路中經常會有多個請求產生多個進程來處理。

為了選取正確的進程運行，調度程序還要考慮CPU的利用率，因為進程切換的代價是比較高的。首先用戶態必須切換到內核態: 然後要保存當前進程的狀態，包括在進程表中存儲寄存器值以便以後重新裝載。接著，通過運行調度算法選定一個新進程；之後，應該將新進程的內存映像重新裝入MMU；最後新進程開始運行。除此之外，進程切換還要使整個記憶體高速緩存失效，強迫緩存從記憶體中動態重新裝入兩次(進入內核一次，離開內核一次)。總之，如果每秒鐘切換進程的次數太多，會耗費大量CPU時間。

#### 1. 進程行為

幾乎所有進程的(磁盤)I/O請求或計算都是交替突發的，如下圖

a) CPU密集型：CPU運行較長的一段時間才會交換。

b) I/O密集型：

隨著CPU越來越快，更多的進程傾向為I/O密集型。這是因為CPU的改進比磁盤的改進快得多。

#### 2. 何時調度

一、在創建一個新進程之後，需要決定是運行父進程還是運行子進程。由於都是處於就緒狀態，就可以任意決定。

二、在一個進程退出時必須做出調度決策。必須從就緒進程集中選擇另外某個進程。

三、當一個進程阻塞在I/O和信號量上或由於其他原因阻塞時，必須選擇另一個進程運行。

四、在一個I/O中斷發生時。如果中斷來自I/O設備，而該設備現在完了工作，某些被阻塞的等待該I/O的進程就成為可運行的就緒進程了。

根據如何處理時鐘中斷，可以把調度算分為:

1. ​	非搶占式: 調度算法不會主動阻塞進程，除非有更高優先級的進程。
2. ​	搶占式: 演算法會挑選一個進程，讓它運行某個固定時段的最大值。如果在該時段結束時，該進程仍在運行，它就被掛起，並選擇另一個進程運行。必須在時間間隔的末端發生時鐘中斷，以便把CPU控制返回給調度程序。

#### 3. 調度算法分類

1. ​	批處理：處理薪水冊、存貨清單、帳目支出、利息計算、索賠處理和其他的周期性的作業。通常使用非搶占式或較長的時鐘周期的搶占式算法。
2. ​	交互式：在伺服器環境中，因為需要服務多個突發的用戶。也避免進程霸占CPU而拒絕為其他進程服務。
3. ​	實時：搶占是不必要的，通常會很快完成工作並阻塞。

#### 4. 調度算法的目標

不同環境中調度算法的一些目標

**所有系統**

- ​	公平--給每個進程公平的CPU份額
- ​	策略強制執行--- 看到所有宣布的策略執行
- ​	平衡--保持系統的所有部分都忙碌

**批處理系統**

- ​	吞吐量--每小時最大作業數
- ​	周轉時間--從提交到終止間的最小時間
- ​	CPU利用率--保持CPU始終忙碌

**交互式系統**

- ​	響應時間--快速響應請求
- ​	均衡性-- 滿足用戶的期望

**實時系統**

- ​	滿足截止時間--避免丟失數據
- ​	可預測性--在多媒體系統中避免品質降低

### 2.4.2 批處理系統中的調度

#### 1. 先來先服務

非搶占式。使用單一隊列。當一個作業進入系統，就立即開始並允許運行他所期望的時間，不會中斷作業。另一個作業進入時，就被安排到隊列的尾部。

優點：易於理解並且便於在程序中運用。一個單鏈表就可以記錄所有的就緒進程。

缺點：短運行時間的進程也會被長時間運行的進程拖慢速度。

#### 2.最短作業優先

這也是一種非搶占式的批處理調度算法。當輸入隊列中的工作都是可以精準的預測作業時間，而且都有相等的重要性。所以輸入時，就可以使用最短作業優先演算法。

只有在所有的作業都可以同時運行的情形下，最短作業演算法才是最優化的。

#### 3. 最短剩餘時間優先

最短作業優先的搶占式版本就是最短剩餘時間優先演算法。調度程序總是選擇剩餘運行時間最短的那個進程。

### 2.4.3 交互式系統中的調度

#### 1. 輪轉調度

每個進程公平的分配時間片(quantum)，如果在時間片結束時該進程還在運行，則將剝奪CPU並分配給另一個進程。如果提前結束進程，則CPU立即切換。調度程序只要維護一張可運行進程列表，當一個進程用完它的時間片後，就被移到隊列的末尾。

進程切換，或是上下文切換時間，稱為管理時間。

要考慮的是運行時間片的長度，如果太短，管理時間占運行時間比率太高，這樣就不合理。但運行時間如果太長，對某些短命令的用戶來說，等待時間又太長。

#### 2. 優先級調度

有些進程的優先次序可能大於其他進程，因此需要加入優先級的思考。

為了防止高優先級的進程無限制的運行，在運行一段時間後，就開始運行次高優先級的進程。

一種動態優先級的作法是將優先級設為`1/f`，f為該進程在上一個時間片中所占的部份。也就是運行時間越短的進程有更高的優先級。

#### 3. 多級隊列

#### 4. 最短進程優先

#### 5. 保證調度

#### 6. 彩票調度

#### 7. 公平分享調度

### 2.4.4實時系統中的調度

實時系統是一種時間起著主導作用的系統。典型地，外部的一種或多種物理設備給了計算機一個刺激，而計算機必須在一個確定的時間範圍內恰當地做出反應。例如，在CD播放器中的計算機獲得從驅動器而來的位流，然後必須在非常短的時間間隔內將流轉換為音樂。如果計算時間過長，那麼音樂就會聽起來有異音。其他的實時系統例子還有，醫院特別護理部門的病人監護裝置，飛機中的自動駕駛系統以及自動化工廠中的機器人控制等。

在所有這些例子中，正確的但是遲到的應答往往比沒有還要糟糕。實時系統通常可以階為硬實時和軟實時，前者的含義是必須滿足絕對的截止時間，後者的含義是雖然不希望偶爾錯失截止時間，但是可以容忍。在這兩種情形中實時性能都是通過把程序劃分為一組進程而實現的，其中每個進程的行為是可預測和提前掌握的。這些進程一般壽命較短，並且極快地就運行完成。在檢測到一個外部信號時，調度程序的任務就是按照滿足所有截止時間的要求調度進程。

實時系統中的事件可以按照響應方式進一步分類為周期性(以規則的時間間隔發生)事件或非周期性(發生時間不可預知)事件。一個系統可能要響應多個周期事件，事件i以周期pi發生，並需要Ci秒cpu時間處理一個事件，那麼可以處理負截的條件是

sigma (pi/Ci)

滿足這個條件的實時系統稱為是可調度的。

作為一個例子，考慮一○有三個周期性事件的軟實時系統，其周期分別是100ms、200ms和500ms。如果這些事件分別需要50ms、30ms和100ms的cpu時間，那麼該系統是可調度的，因為0.5+0.15+0.2<1。

如果有第四個事件加入，其周期為1秒，那麼只要這個事件是不超過每事件150m的cpu時間，那麼該系統就仍然是可調度的。在這個甫算中隱含了一個假設，即上下文切換的開銷很小滿可以忽略不計。

實時系統的調度算法丁以是靜態或動態的。前者在系統開始運行之前作出調度決策；後者在運行過程中進行調度決策。只有在可以提前掌握所完成的工作以及必須滿足的截止時間等全部信息時，靜態調度才能工作。而動態高度算法不需要這些限制。這裡我們只涉及一些特定的算法，而把實時多媒體系統留到第7章去討論。

到目前為止，我們隱含地假設系統中所有進程分屬不同的用戶，並且，進程間相互競爭cpu 。通常情況下確實如此，但有時也有這樣的情況:一個進程有許多子進程並在其控制下運行。例如，一個數據庫管理系統可能有許多子進程，每一個子進程可能處理不同的請求，或每一個子進程實現不同的功能(如請求分析，磁盤訪問等)。主進程完全可能掌握哪一個子進程最重要(或最緊迫)而哪一個最不重要。但是以上應論的調度算法中沒有一個算法從用戶進程接收有關的調度決策信息，這就導致了調度程序很少能夠出最優的選擇

解決問題的方法是將調度機制與調度策略分離，也就是將調度算法以某種形式參數化，而參數可以由用戶週進程填寫。我們再來看一下數據庫的例子。假設內核使用優先級調度算法，但提供一條可供進程設置優先級的系統調用。這樣，盡管父進程本身並不參與調度，但它可以控制如何調度子進程的細節(並改變)。在這裡，調度機制位于內核，而調度進程由用戶進程決定

首先考慮用戶級線程，由以內核並不知道有線程存在，所以內核還是和以前一樣地操作，選取一個進程，假設為a，並給予a以時間片控制。a中的線程調度程序決定哪個線程運行，假設為a1。由於多道線程並不存在時鐘中斷

### 習題

1. ​	圖2-2中給出了三個進程狀態。在理論上，三個狀態可以有六種轉換，每個狀態兩個。但是，圖中只給出了四種轉換。有沒有可能發生質他兩種轉換中的一個或兩個?
2. ​	假設要設計一種先進的計算機體系結構，它使用硬體而不是中斷來完成進程切換。cpu需要哪些信息?請描述用硬體完成進程切換的工作過程。
3. ​	在所有當代計算機中，至少有部分中斷處理程序是用匯編語言編寫的。為什麼?
4. ​	當中斷或系統調用把控制轉給操作系統時，通常將內核堆棧和被中斷進程的運行堆棧分離。為什麼?
5. ​	多個作業能夠併行運行，比它們順序執行完成的要快。假設有兩個作業同時開始執行，每個需要10分鐘的cpu時間。如果順序執行，那麼最後一個作業需要多長時間可以完成?如果併行又需要多長時間可以完成?假設i/o等待占50%。
6. ​	在本章中說明的圖2-11a的模式不適合用於使用記憶體高速緩存的文件伺服器。為什麼不適合?每個進程可以有自己的高速緩存嗎?
7. ​	如果創建一個多線程進程，若子進程得到全部倄進程線程的副本，會出現問題。假如原有線程之一正在等待鍵盤輸入，每個進程有一個。在單線程進程中會發生這種問題嗎?